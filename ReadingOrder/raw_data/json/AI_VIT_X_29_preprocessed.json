{
    "id": "329efcfc-0f94-11ef-8828-426932df3dcf",
    "pdf_path": "./pdf/AI_VIT_X/1506.01497v3.pdf",
    "elements": [
        {
            "bounding_box": [
                {
                    "x": 2173,
                    "y": 122
                },
                {
                    "x": 2196,
                    "y": 122
                },
                {
                    "x": 2196,
                    "y": 150
                },
                {
                    "x": 2173,
                    "y": 150
                }
            ],
            "category": "header",
            "html": "<header id='0' style='font-size:14px'>1</header>",
            "id": 0,
            "page": 1,
            "text": "1"
        },
        {
            "bounding_box": [
                {
                    "x": 242,
                    "y": 245
                },
                {
                    "x": 2102,
                    "y": 245
                },
                {
                    "x": 2102,
                    "y": 465
                },
                {
                    "x": 242,
                    "y": 465
                }
            ],
            "category": "paragraph",
            "html": "<p id='1' style='font-size:22px'>Faster R-CNN: Towards Real-Time Object<br>Detection with Region Proposal Networks</p>",
            "id": 1,
            "page": 1,
            "text": "Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks"
        },
        {
            "bounding_box": [
                {
                    "x": 590,
                    "y": 519
                },
                {
                    "x": 1753,
                    "y": 519
                },
                {
                    "x": 1753,
                    "y": 575
                },
                {
                    "x": 590,
                    "y": 575
                }
            ],
            "category": "paragraph",
            "html": "<p id='2' style='font-size:22px'>Shaoqing Ren, Kaiming He, Ross Girshick, and Jian Sun</p>",
            "id": 2,
            "page": 1,
            "text": "Shaoqing Ren, Kaiming He, Ross Girshick, and Jian Sun"
        },
        {
            "bounding_box": [
                {
                    "x": 227,
                    "y": 653
                },
                {
                    "x": 2112,
                    "y": 653
                },
                {
                    "x": 2112,
                    "y": 1171
                },
                {
                    "x": 227,
                    "y": 1171
                }
            ],
            "category": "paragraph",
            "html": "<p id='3' style='font-size:16px'>Abstract-State-of-the-art object detection networks depend on region proposal algorithms to hypothesize object locations.<br>Advances like SPPnet [1] and Fast R-CNN [2] have reduced the running time of these detection networks, exposing region<br>proposal computation as a bottleneck. In this work, we introduce a Region Proposal Network (RPN) that shares full-image<br>convolutional features with the detection network, thus enabling nearly cost-free region proposals. An RPN is a fully convolutional<br>network that simultaneously predicts object bounds and objectness scores at each position. The RPN is trained end-to-end to<br>generate high-quality region proposals, which are used by Fast R-CNN for detection. We further merge RPN and Fast R-CNN<br>into a single network by sharing their convolutional features-using the recently popular terminology of neural networks with<br>\"attention\" mechanisms, the RPN component tells the unified network where to look. For the very deep VGG-16 model [3],<br>our detection system has a frame rate of 5fps (including all steps) on a GPU, while achieving state-of-the-art object detection<br>accuracy on PASCAL VOC 2007, 2012, and MS COCO datasets with only 300 proposals per image. In ILSVRC and COCO<br>2015 competitions, Faster R-CNN and RPN are the foundations of the 1st-place winning entries in several tracks. Code has been<br>made publicly available.</p>",
            "id": 3,
            "page": 1,
            "text": "Abstract-State-of-the-art object detection networks depend on region proposal algorithms to hypothesize object locations. Advances like SPPnet  and Fast R-CNN  have reduced the running time of these detection networks, exposing region proposal computation as a bottleneck. In this work, we introduce a Region Proposal Network (RPN) that shares full-image convolutional features with the detection network, thus enabling nearly cost-free region proposals. An RPN is a fully convolutional network that simultaneously predicts object bounds and objectness scores at each position. The RPN is trained end-to-end to generate high-quality region proposals, which are used by Fast R-CNN for detection. We further merge RPN and Fast R-CNN into a single network by sharing their convolutional features-using the recently popular terminology of neural networks with \"attention\" mechanisms, the RPN component tells the unified network where to look. For the very deep VGG-16 model , our detection system has a frame rate of 5fps (including all steps) on a GPU, while achieving state-of-the-art object detection accuracy on PASCAL VOC 2007, 2012, and MS COCO datasets with only 300 proposals per image. In ILSVRC and COCO 2015 competitions, Faster R-CNN and RPN are the foundations of the 1st-place winning entries in several tracks. Code has been made publicly available."
        },
        {
            "bounding_box": [
                {
                    "x": 231,
                    "y": 1216
                },
                {
                    "x": 1438,
                    "y": 1216
                },
                {
                    "x": 1438,
                    "y": 1256
                },
                {
                    "x": 231,
                    "y": 1256
                }
            ],
            "category": "paragraph",
            "html": "<p id='4' style='font-size:18px'>Index Terms-Object Detection, Region Proposal, Convolutional Neural Network.</p>",
            "id": 4,
            "page": 1,
            "text": "Index Terms-Object Detection, Region Proposal, Convolutional Neural Network."
        },
        {
            "bounding_box": [
                {
                    "x": 1149,
                    "y": 1280
                },
                {
                    "x": 1194,
                    "y": 1280
                },
                {
                    "x": 1194,
                    "y": 1325
                },
                {
                    "x": 1149,
                    "y": 1325
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='5' style='font-size:20px'>◆</p>",
            "id": 5,
            "page": 1,
            "text": "◆"
        },
        {
            "bounding_box": [
                {
                    "x": 137,
                    "y": 1474
                },
                {
                    "x": 571,
                    "y": 1474
                },
                {
                    "x": 571,
                    "y": 1529
                },
                {
                    "x": 137,
                    "y": 1529
                }
            ],
            "category": "paragraph",
            "html": "<p id='6' style='font-size:16px'>1 INTRODUCTION</p>",
            "id": 6,
            "page": 1,
            "text": "1 INTRODUCTION"
        },
        {
            "bounding_box": [
                {
                    "x": 145,
                    "y": 1547
                },
                {
                    "x": 1154,
                    "y": 1547
                },
                {
                    "x": 1154,
                    "y": 2144
                },
                {
                    "x": 145,
                    "y": 2144
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='7' style='font-size:20px'>Recent advances in object detection are driven by<br>the success of region proposal methods (e.g., [4])<br>and region-based convolutional neural networks (R-<br>CNNs) [5]. Although region-based CNNs were com-<br>putationally expensive as originally developed in [5],<br>their cost has been drastically reduced thanks to shar-<br>ing convolutions across proposals [1], [2]. The latest<br>incarnation, Fast R-CNN [2], achieves near real-time<br>rates using very deep networks [3], when ignoring the<br>time spent on region proposals. Now, proposals are the<br>test-time computational bottleneck in state-of-the-art<br>detection systems.</p>",
            "id": 7,
            "page": 1,
            "text": "Recent advances in object detection are driven by the success of region proposal methods (e.g., ) and region-based convolutional neural networks (RCNNs) . Although region-based CNNs were computationally expensive as originally developed in , their cost has been drastically reduced thanks to sharing convolutions across proposals , . The latest incarnation, Fast R-CNN , achieves near real-time rates using very deep networks , when ignoring the time spent on region proposals. Now, proposals are the test-time computational bottleneck in state-of-the-art detection systems."
        },
        {
            "bounding_box": [
                {
                    "x": 145,
                    "y": 2152
                },
                {
                    "x": 1154,
                    "y": 2152
                },
                {
                    "x": 1154,
                    "y": 2748
                },
                {
                    "x": 145,
                    "y": 2748
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='8' style='font-size:18px'>Region proposal methods typically rely on inex-<br>pensive features and economical inference schemes.<br>Selective Search [4], one of the most popular meth-<br>ods, greedily merges superpixels based on engineered<br>low-level features. Yet when compared to efficient<br>detection networks [2], Selective Search is an order of<br>magnitude slower, at 2 seconds per image in a CPU<br>implementation. EdgeBoxes [6] currently provides the<br>best tradeoff between proposal quality and speed,<br>at 0.2 seconds per image. Nevertheless, the region<br>proposal step still consumes as much running time<br>as the detection network.</p>",
            "id": 8,
            "page": 1,
            "text": "Region proposal methods typically rely on inexpensive features and economical inference schemes. Selective Search , one of the most popular methods, greedily merges superpixels based on engineered low-level features. Yet when compared to efficient detection networks , Selective Search is an order of magnitude slower, at 2 seconds per image in a CPU implementation. EdgeBoxes  currently provides the best tradeoff between proposal quality and speed, at 0.2 seconds per image. Nevertheless, the region proposal step still consumes as much running time as the detection network."
        },
        {
            "bounding_box": [
                {
                    "x": 141,
                    "y": 2800
                },
                {
                    "x": 1153,
                    "y": 2800
                },
                {
                    "x": 1153,
                    "y": 3103
                },
                {
                    "x": 141,
                    "y": 3103
                }
            ],
            "category": "paragraph",
            "html": "<p id='9' style='font-size:14px'>● S. Ren is with University of Science and Technology of China, Hefei,<br>China. This work was done when S. Ren was an intern at Microsoft<br>Research. Email: sqren@mail.ustc.edu.cn<br>● K. He and J. Sun are with Visual Computing Group, Microsoft<br>Research. E-mail: {kahe.jionsun}@microsoft.com<br>● R. Girshick is with Facebook AI Research. The majority of this work<br>was done when R. Girshick was with Microsoft Research. E-mail:<br>rbg@fb.com</p>",
            "id": 9,
            "page": 1,
            "text": "● S. Ren is with University of Science and Technology of China, Hefei, China. This work was done when S. Ren was an intern at Microsoft Research. Email: sqren@mail.ustc.edu.cn ● K. He and J. Sun are with Visual Computing Group, Microsoft Research. E-mail: {kahe.jionsun}@microsoft.com ● R. Girshick is with Facebook AI Research. The majority of this work was done when R. Girshick was with Microsoft Research. E-mail: rbg@fb.com"
        },
        {
            "bounding_box": [
                {
                    "x": 1191,
                    "y": 1480
                },
                {
                    "x": 2198,
                    "y": 1480
                },
                {
                    "x": 2198,
                    "y": 1927
                },
                {
                    "x": 1191,
                    "y": 1927
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='10' style='font-size:18px'>One may note that fast region-based CNNs take<br>advantage of GPUs, while the region proposal meth-<br>ods used in research are implemented on the CPU,<br>making such runtime comparisons inequitable. An ob-<br>vious way to accelerate proposal computation is to re-<br>implement it for the GPU. This may be an effective en-<br>gineering solution, but re-implementation ignores the<br>down-stream detection network and therefore misses<br>important opportunities for sharing computation.</p>",
            "id": 10,
            "page": 1,
            "text": "One may note that fast region-based CNNs take advantage of GPUs, while the region proposal methods used in research are implemented on the CPU, making such runtime comparisons inequitable. An obvious way to accelerate proposal computation is to reimplement it for the GPU. This may be an effective engineering solution, but re-implementation ignores the down-stream detection network and therefore misses important opportunities for sharing computation."
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 1932
                },
                {
                    "x": 2198,
                    "y": 1932
                },
                {
                    "x": 2198,
                    "y": 2425
                },
                {
                    "x": 1190,
                    "y": 2425
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='11' style='font-size:20px'>In this paper, we show that an algorithmic change-<br>computing proposals with a deep convolutional neu-<br>ral network-leads to an elegant and effective solution<br>where proposal computation is nearly cost-free given<br>the detection network's computation. To this end, we<br>introduce novel Region Proposal Networks (RPNs) that<br>share convolutional layers with state-of-the-art object<br>detection networks [1], [2]. By sharing convolutions at<br>test-time, the marginal cost for computing proposals<br>is small (e.g., 10ms per image).</p>",
            "id": 11,
            "page": 1,
            "text": "In this paper, we show that an algorithmic changecomputing proposals with a deep convolutional neural network-leads to an elegant and effective solution where proposal computation is nearly cost-free given the detection network's computation. To this end, we introduce novel Region Proposal Networks (RPNs) that share convolutional layers with state-of-the-art object detection networks , . By sharing convolutions at test-time, the marginal cost for computing proposals is small (e.g., 10ms per image)."
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 2428
                },
                {
                    "x": 2198,
                    "y": 2428
                },
                {
                    "x": 2198,
                    "y": 2974
                },
                {
                    "x": 1190,
                    "y": 2974
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='12' style='font-size:18px'>Our observation is that the convolutional feature<br>maps used by region-based detectors, like Fast R-<br>CNN, can also be used for generating region pro-<br>posals. On top of these convolutional features, we<br>construct an RPN by adding a few additional con-<br>volutional layers that simultaneously regress region<br>bounds and objectness scores at each location on a<br>regular grid. The RPN is thus a kind of fully convo-<br>lutional network (FCN) [7] and can be trained end-to-<br>end specifically for the task for generating detection<br>proposals.</p>",
            "id": 12,
            "page": 1,
            "text": "Our observation is that the convolutional feature maps used by region-based detectors, like Fast RCNN, can also be used for generating region proposals. On top of these convolutional features, we construct an RPN by adding a few additional convolutional layers that simultaneously regress region bounds and objectness scores at each location on a regular grid. The RPN is thus a kind of fully convolutional network (FCN)  and can be trained end-toend specifically for the task for generating detection proposals."
        },
        {
            "bounding_box": [
                {
                    "x": 1188,
                    "y": 2977
                },
                {
                    "x": 2195,
                    "y": 2977
                },
                {
                    "x": 2195,
                    "y": 3127
                },
                {
                    "x": 1188,
                    "y": 3127
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='13' style='font-size:20px'>RPNs are designed to efficiently predict region pro-<br>posals with a wide range of scales and aspect ratios. In<br>contrast to prevalent methods [8], [9], [1], [2] that use</p>",
            "id": 13,
            "page": 1,
            "text": "RPNs are designed to efficiently predict region proposals with a wide range of scales and aspect ratios. In contrast to prevalent methods , , ,  that use"
        },
        {
            "bounding_box": [
                {
                    "x": 60,
                    "y": 835
                },
                {
                    "x": 156,
                    "y": 835
                },
                {
                    "x": 156,
                    "y": 2238
                },
                {
                    "x": 60,
                    "y": 2238
                }
            ],
            "category": "footer",
            "html": "<br><footer id='14' style='font-size:14px'>2016<br>Jan<br>9<br>[cs.CV]<br>arXiv:1506.01497v3</footer>",
            "id": 14,
            "page": 1,
            "text": "2016 Jan 9 [cs.CV] arXiv:1506.01497v3"
        },
        {
            "bounding_box": [
                {
                    "x": 2173,
                    "y": 120
                },
                {
                    "x": 2195,
                    "y": 120
                },
                {
                    "x": 2195,
                    "y": 151
                },
                {
                    "x": 2173,
                    "y": 151
                }
            ],
            "category": "header",
            "html": "<header id='15' style='font-size:14px'>2</header>",
            "id": 15,
            "page": 2,
            "text": "2"
        },
        {
            "bounding_box": [
                {
                    "x": 144,
                    "y": 207
                },
                {
                    "x": 2197,
                    "y": 207
                },
                {
                    "x": 2197,
                    "y": 632
                },
                {
                    "x": 144,
                    "y": 632
                }
            ],
            "category": "figure",
            "html": "<figure><img id='16' style='font-size:14px' alt=\"multiple filter sizes\nmultiple references\nfeature map feature map feature map\nmultiple scaled images\nimage image image\n(a) (b) (c)\" data-coord=\"top-left:(144,207); bottom-right:(2197,632)\" /></figure>",
            "id": 16,
            "page": 2,
            "text": "multiple filter sizes multiple references feature map feature map feature map multiple scaled images image image image (a) (b) (c)"
        },
        {
            "bounding_box": [
                {
                    "x": 141,
                    "y": 651
                },
                {
                    "x": 2200,
                    "y": 651
                },
                {
                    "x": 2200,
                    "y": 810
                },
                {
                    "x": 141,
                    "y": 810
                }
            ],
            "category": "caption",
            "html": "<br><caption id='17' style='font-size:18px'>Figure 1: Different schemes for addressing multiple scales and sizes. (a) Pyramids of images and feature maps<br>are built, and the classifier is run at all scales. (b) Pyramids of filters with multiple scales / sizes are run on<br>the feature map. (c) We use pyramids of reference boxes in the regression functions.</caption>",
            "id": 17,
            "page": 2,
            "text": "Figure 1: Different schemes for addressing multiple scales and sizes. (a) Pyramids of images and feature maps are built, and the classifier is run at all scales. (b) Pyramids of filters with multiple scales / sizes are run on the feature map. (c) We use pyramids of reference boxes in the regression functions."
        },
        {
            "bounding_box": [
                {
                    "x": 144,
                    "y": 905
                },
                {
                    "x": 1153,
                    "y": 905
                },
                {
                    "x": 1153,
                    "y": 1353
                },
                {
                    "x": 144,
                    "y": 1353
                }
            ],
            "category": "paragraph",
            "html": "<p id='18' style='font-size:18px'>pyramids of images (Figure 1, a) or pyramids of filters<br>(Figure 1, b), we introduce novel \"anchor\" boxes<br>that serve as references at multiple scales and aspect<br>ratios. Our scheme can be thought of as a pyramid<br>of regression references (Figure 1, c), which avoids<br>enumerating images or filters of multiple scales or<br>aspect ratios. This model performs well when trained<br>and tested using single-scale images and thus benefits<br>running speed.</p>",
            "id": 18,
            "page": 2,
            "text": "pyramids of images (Figure 1, a) or pyramids of filters (Figure 1, b), we introduce novel \"anchor\" boxes that serve as references at multiple scales and aspect ratios. Our scheme can be thought of as a pyramid of regression references (Figure 1, c), which avoids enumerating images or filters of multiple scales or aspect ratios. This model performs well when trained and tested using single-scale images and thus benefits running speed."
        },
        {
            "bounding_box": [
                {
                    "x": 142,
                    "y": 1356
                },
                {
                    "x": 1152,
                    "y": 1356
                },
                {
                    "x": 1152,
                    "y": 1704
                },
                {
                    "x": 142,
                    "y": 1704
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='19' style='font-size:18px'>To unify RPNs with Fast R-CNN [2] object detec-<br>tion networks, we propose a training scheme that<br>alternates between fine-tuning for the region proposal<br>task and then fine-tuning for object detection, while<br>keeping the proposals fixed. This scheme converges<br>quickly and produces a unified network with convo-<br>lutional features that are shared between both tasks.1</p>",
            "id": 19,
            "page": 2,
            "text": "To unify RPNs with Fast R-CNN  object detection networks, we propose a training scheme that alternates between fine-tuning for the region proposal task and then fine-tuning for object detection, while keeping the proposals fixed. This scheme converges quickly and produces a unified network with convolutional features that are shared between both tasks.1"
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 1708
                },
                {
                    "x": 1154,
                    "y": 1708
                },
                {
                    "x": 1154,
                    "y": 2602
                },
                {
                    "x": 143,
                    "y": 2602
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='20' style='font-size:18px'>We comprehensively evaluate our method on the<br>PASCAL VOC detection benchmarks [11] where RPNs<br>with Fast R-CNNs produce detection accuracy bet-<br>ter than the strong baseline of Selective Search with<br>Fast R-CNNs. Meanwhile, our method waives nearly<br>all computational burdens of Selective Search at<br>test-time-the effective running time for proposals<br>is just 10 milliseconds. Using the expensive very<br>deep models of [3], our detection method still has<br>a frame rate of 5fps (including all steps) on a GPU,<br>and thus is a practical object detection system in<br>terms of both speed and accuracy. We also report<br>results on the MS COCO dataset [12] and investi-<br>gate the improvements on PASCAL VOC using the<br>COCO data. Code has been made publicly available<br>at https : / / github · com/ shaoqingren/ faster_<br>rcnn (in MATLAB) and https : / / github · com/<br>rbgirshick /py-faster- rcnn (in Python).</p>",
            "id": 20,
            "page": 2,
            "text": "We comprehensively evaluate our method on the PASCAL VOC detection benchmarks  where RPNs with Fast R-CNNs produce detection accuracy better than the strong baseline of Selective Search with Fast R-CNNs. Meanwhile, our method waives nearly all computational burdens of Selective Search at test-time-the effective running time for proposals is just 10 milliseconds. Using the expensive very deep models of , our detection method still has a frame rate of 5fps (including all steps) on a GPU, and thus is a practical object detection system in terms of both speed and accuracy. We also report results on the MS COCO dataset  and investigate the improvements on PASCAL VOC using the COCO data. Code has been made publicly available at https : / / github · com/ shaoqingren/ faster_ rcnn (in MATLAB) and https : / / github · com/ rbgirshick /py-faster- rcnn (in Python)."
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 2608
                },
                {
                    "x": 1153,
                    "y": 2608
                },
                {
                    "x": 1153,
                    "y": 2954
                },
                {
                    "x": 143,
                    "y": 2954
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='21' style='font-size:18px'>A preliminary version of this manuscript was pub-<br>lished previously [10]. Since then, the frameworks of<br>RPN and Faster R-CNN have been adopted and gen-<br>eralized to other methods, such as 3D object detection<br>[13], part-based detection [14], instance segmentation<br>[15], and image captioning [16]. Our fast and effective<br>object detection system has also been built in com-</p>",
            "id": 21,
            "page": 2,
            "text": "A preliminary version of this manuscript was published previously . Since then, the frameworks of RPN and Faster R-CNN have been adopted and generalized to other methods, such as 3D object detection , part-based detection , instance segmentation , and image captioning . Our fast and effective object detection system has also been built in com-"
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 3005
                },
                {
                    "x": 1151,
                    "y": 3005
                },
                {
                    "x": 1151,
                    "y": 3122
                },
                {
                    "x": 143,
                    "y": 3122
                }
            ],
            "category": "paragraph",
            "html": "<p id='22' style='font-size:16px'>1. Since the publication of the conference version of this paper<br>[10], we have also found that RPNs can be trained jointly with Fast<br>R-CNN networks leading to less training time.</p>",
            "id": 22,
            "page": 2,
            "text": "1. Since the publication of the conference version of this paper , we have also found that RPNs can be trained jointly with Fast R-CNN networks leading to less training time."
        },
        {
            "bounding_box": [
                {
                    "x": 1188,
                    "y": 907
                },
                {
                    "x": 2196,
                    "y": 907
                },
                {
                    "x": 2196,
                    "y": 1003
                },
                {
                    "x": 1188,
                    "y": 1003
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='23' style='font-size:18px'>mercial systems such as at Pinterests [17], with user<br>engagement improvements reported.</p>",
            "id": 23,
            "page": 2,
            "text": "mercial systems such as at Pinterests , with user engagement improvements reported."
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 1007
                },
                {
                    "x": 2199,
                    "y": 1007
                },
                {
                    "x": 2199,
                    "y": 1657
                },
                {
                    "x": 1190,
                    "y": 1657
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='24' style='font-size:18px'>In ILSVRC and COCO 2015 competitions, Faster<br>R-CNN and RPN are the basis of several 1st-place<br>entries [18] in the tracks of ImageNet detection, Ima-<br>geNet localization, COCO detection, and COCO seg-<br>mentation. RPNs completely learn to propose regions<br>from data, and thus can easily benefit from deeper<br>and more expressive features (such as the 101-layer<br>residual nets adopted in [18]). Faster R-CNN and RPN<br>are also used by several other leading entries in these<br>competitions2. These results suggest that our method<br>is not only a cost-efficient solution for practical usage,<br>but also an effective way of improving object detec-<br>tion accuracy.</p>",
            "id": 24,
            "page": 2,
            "text": "In ILSVRC and COCO 2015 competitions, Faster R-CNN and RPN are the basis of several 1st-place entries  in the tracks of ImageNet detection, ImageNet localization, COCO detection, and COCO segmentation. RPNs completely learn to propose regions from data, and thus can easily benefit from deeper and more expressive features (such as the 101-layer residual nets adopted in ). Faster R-CNN and RPN are also used by several other leading entries in these competitions2. These results suggest that our method is not only a cost-efficient solution for practical usage, but also an effective way of improving object detection accuracy."
        },
        {
            "bounding_box": [
                {
                    "x": 1189,
                    "y": 1733
                },
                {
                    "x": 1647,
                    "y": 1733
                },
                {
                    "x": 1647,
                    "y": 1783
                },
                {
                    "x": 1189,
                    "y": 1783
                }
            ],
            "category": "paragraph",
            "html": "<p id='25' style='font-size:22px'>2 RELATED WORK</p>",
            "id": 25,
            "page": 2,
            "text": "2 RELATED WORK"
        },
        {
            "bounding_box": [
                {
                    "x": 1191,
                    "y": 1810
                },
                {
                    "x": 2198,
                    "y": 1810
                },
                {
                    "x": 2198,
                    "y": 2359
                },
                {
                    "x": 1191,
                    "y": 2359
                }
            ],
            "category": "paragraph",
            "html": "<p id='26' style='font-size:20px'>Object Proposals. There is a large literature on object<br>proposal methods. Comprehensive surveys and com-<br>parisons of object proposal methods can be found in<br>[19], [20], [21]. Widely used object proposal methods<br>include those based on grouping super-pixels (e.g.,<br>Selective Search [4], CPMC [22], MCG [23]) and those<br>based on sliding windows (e.g., objectness in windows<br>[24], EdgeBoxes [6]). Object proposal methods were<br>adopted as external modules independent of the de-<br>tectors (e.g., Selective Search [4] object detectors, R-<br>CNN [5], and Fast R-CNN [2]).</p>",
            "id": 26,
            "page": 2,
            "text": "Object Proposals. There is a large literature on object proposal methods. Comprehensive surveys and comparisons of object proposal methods can be found in , , . Widely used object proposal methods include those based on grouping super-pixels (e.g., Selective Search , CPMC , MCG ) and those based on sliding windows (e.g., objectness in windows , EdgeBoxes ). Object proposal methods were adopted as external modules independent of the detectors (e.g., Selective Search  object detectors, RCNN , and Fast R-CNN )."
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 2380
                },
                {
                    "x": 2199,
                    "y": 2380
                },
                {
                    "x": 2199,
                    "y": 3032
                },
                {
                    "x": 1190,
                    "y": 3032
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='27' style='font-size:20px'>Deep Networks for Object Detection. The R-CNN<br>method [5] trains CNNs end-to-end to classify the<br>proposal regions into object categories or background.<br>R-CNN mainly plays as a classifier, and it does not<br>predict object bounds (except for refining by bounding<br>box regression). Its accuracy depends on the perfor-<br>mance of the region proposal module (see compar-<br>isons in [20]). Several papers have proposed ways of<br>using deep networks for predicting object bounding<br>boxes [25], [9], [26], [27]. In the OverFeat method [9],<br>a fully-connected layer is trained to predict the box<br>coordinates for the localization task that assumes a<br>single object. The fully-connected layer is then turned</p>",
            "id": 27,
            "page": 2,
            "text": "Deep Networks for Object Detection. The R-CNN method  trains CNNs end-to-end to classify the proposal regions into object categories or background. R-CNN mainly plays as a classifier, and it does not predict object bounds (except for refining by bounding box regression). Its accuracy depends on the performance of the region proposal module (see comparisons in ). Several papers have proposed ways of using deep networks for predicting object bounding boxes , , , . In the OverFeat method , a fully-connected layer is trained to predict the box coordinates for the localization task that assumes a single object. The fully-connected layer is then turned"
        },
        {
            "bounding_box": [
                {
                    "x": 1221,
                    "y": 3081
                },
                {
                    "x": 2092,
                    "y": 3081
                },
                {
                    "x": 2092,
                    "y": 3121
                },
                {
                    "x": 1221,
                    "y": 3121
                }
            ],
            "category": "paragraph",
            "html": "<p id='28' style='font-size:16px'>2. http:/ / image-net.org/ challenges/LSVRC/2015 /results</p>",
            "id": 28,
            "page": 2,
            "text": "2. http:/ / image-net.org/ challenges/LSVRC/2015 /results"
        },
        {
            "bounding_box": [
                {
                    "x": 2173,
                    "y": 121
                },
                {
                    "x": 2195,
                    "y": 121
                },
                {
                    "x": 2195,
                    "y": 149
                },
                {
                    "x": 2173,
                    "y": 149
                }
            ],
            "category": "header",
            "html": "<header id='29' style='font-size:14px'>3</header>",
            "id": 29,
            "page": 3,
            "text": "3"
        },
        {
            "bounding_box": [
                {
                    "x": 154,
                    "y": 199
                },
                {
                    "x": 1142,
                    "y": 199
                },
                {
                    "x": 1142,
                    "y": 1189
                },
                {
                    "x": 154,
                    "y": 1189
                }
            ],
            "category": "figure",
            "html": "<figure><img id='30' style='font-size:20px' alt=\"classifier\nRoI pooling\n/\nproposals\nRegion Proposal Network 1\nfeature maps\n↑\nconv layers\nimage\" data-coord=\"top-left:(154,199); bottom-right:(1142,1189)\" /></figure>",
            "id": 30,
            "page": 3,
            "text": "classifier RoI pooling / proposals Region Proposal Network 1 feature maps ↑ conv layers image"
        },
        {
            "bounding_box": [
                {
                    "x": 145,
                    "y": 1209
                },
                {
                    "x": 1152,
                    "y": 1209
                },
                {
                    "x": 1152,
                    "y": 1358
                },
                {
                    "x": 145,
                    "y": 1358
                }
            ],
            "category": "caption",
            "html": "<br><caption id='31' style='font-size:16px'>Figure 2: Faster R-CNN is a single, unified network<br>for object detection. The RPN module serves as the<br>'attention' of this unified network.</caption>",
            "id": 31,
            "page": 3,
            "text": "Figure 2: Faster R-CNN is a single, unified network for object detection. The RPN module serves as the 'attention' of this unified network."
        },
        {
            "bounding_box": [
                {
                    "x": 145,
                    "y": 1456
                },
                {
                    "x": 1154,
                    "y": 1456
                },
                {
                    "x": 1154,
                    "y": 2203
                },
                {
                    "x": 145,
                    "y": 2203
                }
            ],
            "category": "paragraph",
            "html": "<p id='32' style='font-size:18px'>into a convolutional layer for detecting multiple class-<br>specific objects. The MultiBox methods [26], [27] gen-<br>erate region proposals from a network whose last<br>fully-connected layer simultaneously predicts mul-<br>tiple class-agnostic boxes, generalizing the \"single-<br>box\" fashion of OverFeat. These class-agnostic boxes<br>are used as proposals for R-CNN [5]. The MultiBox<br>proposal network is applied on a single image crop or<br>multiple large image crops (e.g., 224x224), in contrast<br>to our fully convolutional scheme. MultiBox does not<br>share features between the proposal and detection<br>networks. We discuss OverFeat and MultiBox in more<br>depth later in context with our method. Concurrent<br>with our work, the DeepMask method [28] is devel-<br>oped for learning segmentation proposals.</p>",
            "id": 32,
            "page": 3,
            "text": "into a convolutional layer for detecting multiple classspecific objects. The MultiBox methods ,  generate region proposals from a network whose last fully-connected layer simultaneously predicts multiple class-agnostic boxes, generalizing the \"singlebox\" fashion of OverFeat. These class-agnostic boxes are used as proposals for R-CNN . The MultiBox proposal network is applied on a single image crop or multiple large image crops (e.g., 224x224), in contrast to our fully convolutional scheme. MultiBox does not share features between the proposal and detection networks. We discuss OverFeat and MultiBox in more depth later in context with our method. Concurrent with our work, the DeepMask method  is developed for learning segmentation proposals."
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 2205
                },
                {
                    "x": 1153,
                    "y": 2205
                },
                {
                    "x": 1153,
                    "y": 2755
                },
                {
                    "x": 143,
                    "y": 2755
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='33' style='font-size:18px'>Shared computation of convolutions [9], [1], [29],<br>[7], [2] has been attracting increasing attention for ef-<br>ficient, yet accurate, visual recognition. The OverFeat<br>paper [9] computes convolutional features from an<br>image pyramid for classification, localization, and de-<br>tection. Adaptively-sized pooling (SPP) [1] on shared<br>convolutional feature maps is developed for efficient<br>region-based object detection [1], [30] and semantic<br>segmentation [29]. Fast R-CNN [2] enables end-to-end<br>detector training on shared convolutional features and<br>shows compelling accuracy and speed.</p>",
            "id": 33,
            "page": 3,
            "text": "Shared computation of convolutions , , , ,  has been attracting increasing attention for efficient, yet accurate, visual recognition. The OverFeat paper  computes convolutional features from an image pyramid for classification, localization, and detection. Adaptively-sized pooling (SPP)  on shared convolutional feature maps is developed for efficient region-based object detection ,  and semantic segmentation . Fast R-CNN  enables end-to-end detector training on shared convolutional features and shows compelling accuracy and speed."
        },
        {
            "bounding_box": [
                {
                    "x": 145,
                    "y": 2806
                },
                {
                    "x": 595,
                    "y": 2806
                },
                {
                    "x": 595,
                    "y": 2856
                },
                {
                    "x": 145,
                    "y": 2856
                }
            ],
            "category": "paragraph",
            "html": "<p id='34' style='font-size:22px'>3 FASTER R-CNN</p>",
            "id": 34,
            "page": 3,
            "text": "3 FASTER R-CNN"
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 2874
                },
                {
                    "x": 1152,
                    "y": 2874
                },
                {
                    "x": 1152,
                    "y": 3127
                },
                {
                    "x": 143,
                    "y": 3127
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='35' style='font-size:16px'>Our object detection system, called Faster R-CNN, is<br>composed of two modules. The first module is a deep<br>fully convolutional network that proposes regions,<br>and the second module is the Fast R-CNN detector [2]<br>that uses the proposed regions. The entire system is a</p>",
            "id": 35,
            "page": 3,
            "text": "Our object detection system, called Faster R-CNN, is composed of two modules. The first module is a deep fully convolutional network that proposes regions, and the second module is the Fast R-CNN detector  that uses the proposed regions. The entire system is a"
        },
        {
            "bounding_box": [
                {
                    "x": 1188,
                    "y": 236
                },
                {
                    "x": 2196,
                    "y": 236
                },
                {
                    "x": 2196,
                    "y": 631
                },
                {
                    "x": 1188,
                    "y": 631
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='36' style='font-size:18px'>single, unified network for object detection (Figure 2).<br>Using the recently popular terminology of neural<br>networks with 'attention' [31] mechanisms, the RPN<br>module tells the Fast R-CNN module where to look.<br>In Section 3.1 we introduce the designs and properties<br>of the network for region proposal. In Section 3.2 we<br>develop algorithms for training both modules with<br>features shared.</p>",
            "id": 36,
            "page": 3,
            "text": "single, unified network for object detection (Figure 2). Using the recently popular terminology of neural networks with 'attention'  mechanisms, the RPN module tells the Fast R-CNN module where to look. In Section 3.1 we introduce the designs and properties of the network for region proposal. In Section 3.2 we develop algorithms for training both modules with features shared."
        },
        {
            "bounding_box": [
                {
                    "x": 1188,
                    "y": 679
                },
                {
                    "x": 1825,
                    "y": 679
                },
                {
                    "x": 1825,
                    "y": 725
                },
                {
                    "x": 1188,
                    "y": 725
                }
            ],
            "category": "paragraph",
            "html": "<p id='37' style='font-size:20px'>3.1 Region Proposal Networks</p>",
            "id": 37,
            "page": 3,
            "text": "3.1 Region Proposal Networks"
        },
        {
            "bounding_box": [
                {
                    "x": 1191,
                    "y": 742
                },
                {
                    "x": 2198,
                    "y": 742
                },
                {
                    "x": 2198,
                    "y": 1336
                },
                {
                    "x": 1191,
                    "y": 1336
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='38' style='font-size:16px'>A Region Proposal Network (RPN) takes an image<br>(of any size) as input and outputs a set of rectangular<br>object proposals, each with an objectness score.3 We<br>model this process with a fully convolutional network<br>[7], which we describe in this section. Because our ulti-<br>mate goal is to share computation with a Fast R-CNN<br>object detection network [2], we assume that both nets<br>share a common set of convolutional layers. In our ex-<br>periments, we investigate the Zeiler and Fergus model<br>[32] (ZF), which has 5 shareable convolutional layers<br>and the Simonyan and Zisserman model [3] (VGG-16),<br>which has 13 shareable convolutional layers.</p>",
            "id": 38,
            "page": 3,
            "text": "A Region Proposal Network (RPN) takes an image (of any size) as input and outputs a set of rectangular object proposals, each with an objectness score.3 We model this process with a fully convolutional network , which we describe in this section. Because our ultimate goal is to share computation with a Fast R-CNN object detection network , we assume that both nets share a common set of convolutional layers. In our experiments, we investigate the Zeiler and Fergus model  (ZF), which has 5 shareable convolutional layers and the Simonyan and Zisserman model  (VGG-16), which has 13 shareable convolutional layers."
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 1339
                },
                {
                    "x": 2199,
                    "y": 1339
                },
                {
                    "x": 2199,
                    "y": 2336
                },
                {
                    "x": 1190,
                    "y": 2336
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='39' style='font-size:16px'>To generate region proposals, we slide a small<br>network over the convolutional feature map output<br>by the last shared convolutional layer. This small<br>network takes as input an n x n spatial window of<br>the input convolutional feature map. Each sliding<br>window is mapped to a lower-dimensional feature<br>(256-d for ZF and 512-d for VGG, with ReLU [33]<br>following). This feature is fed into two sibling fully-<br>connected layers-a box-regression layer (reg) and a<br>box-classification layer (cls). We use n = 3 in this<br>paper, noting that the effective receptive field on the<br>input image is large (171 and 228 pixels for ZF and<br>VGG, respectively). This mini-network is illustrated<br>at a single position in Figure 3 (left). Note that be-<br>cause the mini-network operates in a sliding-window<br>fashion, the fully-connected layers are shared across<br>all spatial locations. This architecture is naturally im-<br>plemented with an n x n convolutional layer followed<br>by two sibling 1 x 1 convolutional layers (for reg and<br>cls, respectively).</p>",
            "id": 39,
            "page": 3,
            "text": "To generate region proposals, we slide a small network over the convolutional feature map output by the last shared convolutional layer. This small network takes as input an n x n spatial window of the input convolutional feature map. Each sliding window is mapped to a lower-dimensional feature (256-d for ZF and 512-d for VGG, with ReLU  following). This feature is fed into two sibling fullyconnected layers-a box-regression layer (reg) and a box-classification layer (cls). We use n = 3 in this paper, noting that the effective receptive field on the input image is large (171 and 228 pixels for ZF and VGG, respectively). This mini-network is illustrated at a single position in Figure 3 (left). Note that because the mini-network operates in a sliding-window fashion, the fully-connected layers are shared across all spatial locations. This architecture is naturally implemented with an n x n convolutional layer followed by two sibling 1 x 1 convolutional layers (for reg and cls, respectively)."
        },
        {
            "bounding_box": [
                {
                    "x": 1192,
                    "y": 2366
                },
                {
                    "x": 1488,
                    "y": 2366
                },
                {
                    "x": 1488,
                    "y": 2410
                },
                {
                    "x": 1192,
                    "y": 2410
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='40' style='font-size:18px'>3.1.1 Anchors</p>",
            "id": 40,
            "page": 3,
            "text": "3.1.1 Anchors"
        },
        {
            "bounding_box": [
                {
                    "x": 1189,
                    "y": 2424
                },
                {
                    "x": 2195,
                    "y": 2424
                },
                {
                    "x": 2195,
                    "y": 2822
                },
                {
                    "x": 1189,
                    "y": 2822
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='41' style='font-size:18px'>At each sliding-window location, we simultaneously<br>predict multiple region proposals, where the number<br>of maximum possible proposals for each location is<br>denoted as k. So the reg layer has 4k outputs encoding<br>the coordinates of k boxes, and the cls layer outputs<br>2k scores that estimate probability of object or not<br>object for each proposal4. The k proposals are param-<br>eterized relative to k reference boxes, which we call</p>",
            "id": 41,
            "page": 3,
            "text": "At each sliding-window location, we simultaneously predict multiple region proposals, where the number of maximum possible proposals for each location is denoted as k. So the reg layer has 4k outputs encoding the coordinates of k boxes, and the cls layer outputs 2k scores that estimate probability of object or not object for each proposal4. The k proposals are parameterized relative to k reference boxes, which we call"
        },
        {
            "bounding_box": [
                {
                    "x": 1189,
                    "y": 2855
                },
                {
                    "x": 2196,
                    "y": 2855
                },
                {
                    "x": 2196,
                    "y": 3003
                },
                {
                    "x": 1189,
                    "y": 3003
                }
            ],
            "category": "paragraph",
            "html": "<p id='42' style='font-size:14px'>3. \"Region\" is a generic term and in this paper we only consider<br>rectangular regions, as is common for many methods (e.g., [27], [4],<br>[6]). \"Objectness\" measures membership to a set of object classes<br>vs. background.</p>",
            "id": 42,
            "page": 3,
            "text": "3. \"Region\" is a generic term and in this paper we only consider rectangular regions, as is common for many methods (e.g., , , ). \"Objectness\" measures membership to a set of object classes vs. background."
        },
        {
            "bounding_box": [
                {
                    "x": 1189,
                    "y": 3010
                },
                {
                    "x": 2195,
                    "y": 3010
                },
                {
                    "x": 2195,
                    "y": 3119
                },
                {
                    "x": 1189,
                    "y": 3119
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='43' style='font-size:14px'>4. For simplicity we implement the cls layer as a two-class<br>softmax layer. Alternatively, one may use logistic regression to<br>produce k scores.</p>",
            "id": 43,
            "page": 3,
            "text": "4. For simplicity we implement the cls layer as a two-class softmax layer. Alternatively, one may use logistic regression to produce k scores."
        },
        {
            "bounding_box": [
                {
                    "x": 163,
                    "y": 214
                },
                {
                    "x": 2172,
                    "y": 214
                },
                {
                    "x": 2172,
                    "y": 858
                },
                {
                    "x": 163,
                    "y": 858
                }
            ],
            "category": "figure",
            "html": "<figure><img id='44' style='font-size:14px' alt=\"2k scores 4k coordinates ← k anchor boxes person :0.992\ndog:0.994\nhorse:0.993\ncls layer reg layer car:1.000\ncat:0.982\nperson :0.979\ndog:0.9 7\n256-d\nintermediate layer\nbus : 0.996\nboat:0.970\nperson:0.983\nperson :0.736 person :0.983\nperson:0.925\nperson :0.989\nLickety Split\nsliding window\nconv featuremap\" data-coord=\"top-left:(163,214); bottom-right:(2172,858)\" /></figure>",
            "id": 44,
            "page": 4,
            "text": "2k scores 4k coordinates ← k anchor boxes person :0.992 dog:0.994 horse:0.993 cls layer reg layer car:1.000 cat:0.982 person :0.979 dog:0.9 7 256-d intermediate layer bus : 0.996 boat:0.970 person:0.983 person :0.736 person :0.983 person:0.925 person :0.989 Lickety Split sliding window conv featuremap"
        },
        {
            "bounding_box": [
                {
                    "x": 147,
                    "y": 887
                },
                {
                    "x": 2193,
                    "y": 887
                },
                {
                    "x": 2193,
                    "y": 989
                },
                {
                    "x": 147,
                    "y": 989
                }
            ],
            "category": "caption",
            "html": "<caption id='45' style='font-size:22px'>Figure 3: Left: Region Proposal Network (RPN). Right: Example detections using RPN proposals on PASCAL<br>VOC 2007 test. Our method detects objects in a wide range of scales and aspect ratios.</caption>",
            "id": 45,
            "page": 4,
            "text": "Figure 3: Left: Region Proposal Network (RPN). Right: Example detections using RPN proposals on PASCAL VOC 2007 test. Our method detects objects in a wide range of scales and aspect ratios."
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 1090
                },
                {
                    "x": 1151,
                    "y": 1090
                },
                {
                    "x": 1151,
                    "y": 1434
                },
                {
                    "x": 143,
                    "y": 1434
                }
            ],
            "category": "paragraph",
            "html": "<p id='46' style='font-size:18px'>anchors. An anchor is centered at the sliding window<br>in question, and is associated with a scale and aspect<br>ratio (Figure 3, left). By default we use 3 scales and<br>3 aspect ratios, yielding k = 9 anchors at each sliding<br>position. For a convolutional feature map of a size<br>W x H (typically ~2,400), there are W Hk anchors in<br>total.</p>",
            "id": 46,
            "page": 4,
            "text": "anchors. An anchor is centered at the sliding window in question, and is associated with a scale and aspect ratio (Figure 3, left). By default we use 3 scales and 3 aspect ratios, yielding k = 9 anchors at each sliding position. For a convolutional feature map of a size W x H (typically ~2,400), there are W Hk anchors in total."
        },
        {
            "bounding_box": [
                {
                    "x": 145,
                    "y": 1466
                },
                {
                    "x": 731,
                    "y": 1466
                },
                {
                    "x": 731,
                    "y": 1510
                },
                {
                    "x": 145,
                    "y": 1510
                }
            ],
            "category": "paragraph",
            "html": "<p id='47' style='font-size:18px'>Translation-Invariant Anchors</p>",
            "id": 47,
            "page": 4,
            "text": "Translation-Invariant Anchors"
        },
        {
            "bounding_box": [
                {
                    "x": 144,
                    "y": 1522
                },
                {
                    "x": 1152,
                    "y": 1522
                },
                {
                    "x": 1152,
                    "y": 2118
                },
                {
                    "x": 144,
                    "y": 2118
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='48' style='font-size:18px'>An important property of our approach is that it<br>is translation invariant, both in terms of the anchors<br>and the functions that compute proposals relative to<br>the anchors. If one translates an object in an image,<br>the proposal should translate and the same function<br>should be able to predict the proposal in either lo-<br>cation. This translation-invariant property is guaran-<br>teed by our method5. As a comparison, the MultiBox<br>method [27] uses k-means to generate 800 anchors,<br>which are not translation invariant. So MultiBox does<br>not guarantee that the same proposal is generated if<br>an object is translated.</p>",
            "id": 48,
            "page": 4,
            "text": "An important property of our approach is that it is translation invariant, both in terms of the anchors and the functions that compute proposals relative to the anchors. If one translates an object in an image, the proposal should translate and the same function should be able to predict the proposal in either location. This translation-invariant property is guaranteed by our method5. As a comparison, the MultiBox method  uses k-means to generate 800 anchors, which are not translation invariant. So MultiBox does not guarantee that the same proposal is generated if an object is translated."
        },
        {
            "bounding_box": [
                {
                    "x": 144,
                    "y": 2126
                },
                {
                    "x": 1153,
                    "y": 2126
                },
                {
                    "x": 1153,
                    "y": 2821
                },
                {
                    "x": 144,
                    "y": 2821
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='49' style='font-size:20px'>The translation-invariant property also reduces the<br>model size. MultiBox has a (4 + 1) x 800-dimensional<br>fully-connected output layer, whereas our method has<br>a (4 + 2) x 9-dimensional convolutional output layer<br>in the case of k = 9 anchors. As a result, our output<br>parameters (512 x (4 + 2) x 9<br>layer has 2.8 x 104<br>for VGG-16), two orders of magnitude fewer than<br>parameters<br>MultiBox's output layer that has 6.1 x 106<br>(1536 x (4 + 1) x 800 for GoogleNet [34] in MultiBox<br>[27]). If considering the feature projection layers, our<br>proposal layers still have an order of magnitude fewer<br>parameters than MultiBox6. We expect our method<br>to have less risk of overfitting on small datasets, like<br>PASCAL VOC.</p>",
            "id": 49,
            "page": 4,
            "text": "The translation-invariant property also reduces the model size. MultiBox has a (4 + 1) x 800-dimensional fully-connected output layer, whereas our method has a (4 + 2) x 9-dimensional convolutional output layer in the case of k = 9 anchors. As a result, our output parameters (512 x (4 + 2) x 9 layer has 2.8 x 104 for VGG-16), two orders of magnitude fewer than parameters MultiBox's output layer that has 6.1 x 106 (1536 x (4 + 1) x 800 for GoogleNet  in MultiBox ). If considering the feature projection layers, our proposal layers still have an order of magnitude fewer parameters than MultiBox6. We expect our method to have less risk of overfitting on small datasets, like PASCAL VOC."
        },
        {
            "bounding_box": [
                {
                    "x": 144,
                    "y": 2890
                },
                {
                    "x": 1152,
                    "y": 2890
                },
                {
                    "x": 1152,
                    "y": 2965
                },
                {
                    "x": 144,
                    "y": 2965
                }
            ],
            "category": "paragraph",
            "html": "<p id='50' style='font-size:14px'>5. As is the case of FCNs [7], our network is translation invariant<br>up to the network's total stride.</p>",
            "id": 50,
            "page": 4,
            "text": "5. As is the case of FCNs , our network is translation invariant up to the network's total stride."
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 2968
                },
                {
                    "x": 1152,
                    "y": 2968
                },
                {
                    "x": 1152,
                    "y": 3121
                },
                {
                    "x": 143,
                    "y": 3121
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='51' style='font-size:16px'>6. Considering the feature projection layers, our proposal layers`<br>parameter count is 3 x 3 x 512 x 512 + 512 x 6 x 9 = 2.4 x 106;<br>MultiBox's proposal layers` parameter count is 7 x 7 x (64 + 96 +<br>64 + 64) x 1536 + 1536 x 5 x 800 = 27 x 106.</p>",
            "id": 51,
            "page": 4,
            "text": "6. Considering the feature projection layers, our proposal layers` parameter count is 3 x 3 x 512 x 512 + 512 x 6 x 9 = 2.4 x 106; MultiBox's proposal layers` parameter count is 7 x 7 x (64 + 96 + 64 + 64) x 1536 + 1536 x 5 x 800 = 27 x 106."
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 1091
                },
                {
                    "x": 2097,
                    "y": 1091
                },
                {
                    "x": 2097,
                    "y": 1133
                },
                {
                    "x": 1190,
                    "y": 1133
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='52' style='font-size:20px'>Multi-Scale Anchors as Regression References</p>",
            "id": 52,
            "page": 4,
            "text": "Multi-Scale Anchors as Regression References"
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 1140
                },
                {
                    "x": 2198,
                    "y": 1140
                },
                {
                    "x": 2198,
                    "y": 1979
                },
                {
                    "x": 1190,
                    "y": 1979
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='53' style='font-size:22px'>Our design of anchors presents a novel scheme<br>for addressing multiple scales (and aspect ratios). As<br>shown in Figure 1, there have been two popular ways<br>for multi-scale predictions. The first way is based on<br>image/ feature pyramids, e.g., in DPM [8] and CNN-<br>based methods [9], [1], [2]. The images are resized at<br>multiple scales, and feature maps (HOG [8] or deep<br>convolutional features [9], [1], [2]) are computed for<br>each scale (Figure 1(a)). This way is often useful but<br>is time-consuming. The second way is to use sliding<br>windows of multiple scales (and/ or aspect ratios) on<br>the feature maps. For example, in DPM [8], models<br>of different aspect ratios are trained separately using<br>different filter sizes (such as 5x7 and 7x5). If this way<br>is used to address multiple scales, it can be thought<br>of as a \"pyramid of filters\" (Figure 1(b)). The second<br>way is usually adopted jointly with the first way [8].</p>",
            "id": 53,
            "page": 4,
            "text": "Our design of anchors presents a novel scheme for addressing multiple scales (and aspect ratios). As shown in Figure 1, there have been two popular ways for multi-scale predictions. The first way is based on image/ feature pyramids, e.g., in DPM  and CNNbased methods , , . The images are resized at multiple scales, and feature maps (HOG  or deep convolutional features , , ) are computed for each scale (Figure 1(a)). This way is often useful but is time-consuming. The second way is to use sliding windows of multiple scales (and/ or aspect ratios) on the feature maps. For example, in DPM , models of different aspect ratios are trained separately using different filter sizes (such as 5x7 and 7x5). If this way is used to address multiple scales, it can be thought of as a \"pyramid of filters\" (Figure 1(b)). The second way is usually adopted jointly with the first way ."
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 1977
                },
                {
                    "x": 2197,
                    "y": 1977
                },
                {
                    "x": 2197,
                    "y": 2428
                },
                {
                    "x": 1190,
                    "y": 2428
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='54' style='font-size:20px'>As a comparison, our anchor-based method is built<br>on a pyramid of anchors, which is more cost-efficient.<br>Our method classifies and regresses bounding boxes<br>with reference to anchor boxes of multiple scales and<br>aspect ratios. It only relies on images and feature<br>maps of a single scale, and uses filters (sliding win-<br>dows on the feature map) of a single size. We show by<br>experiments the effects of this scheme for addressing<br>multiple scales and sizes (Table 8).</p>",
            "id": 54,
            "page": 4,
            "text": "As a comparison, our anchor-based method is built on a pyramid of anchors, which is more cost-efficient. Our method classifies and regresses bounding boxes with reference to anchor boxes of multiple scales and aspect ratios. It only relies on images and feature maps of a single scale, and uses filters (sliding windows on the feature map) of a single size. We show by experiments the effects of this scheme for addressing multiple scales and sizes (Table 8)."
        },
        {
            "bounding_box": [
                {
                    "x": 1189,
                    "y": 2431
                },
                {
                    "x": 2196,
                    "y": 2431
                },
                {
                    "x": 2196,
                    "y": 2729
                },
                {
                    "x": 1189,
                    "y": 2729
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='55' style='font-size:20px'>Because of this multi-scale design based on anchors,<br>we can simply use the convolutional features com-<br>puted on a single-scale image, as is also done by<br>the Fast R-CNN detector [2]. The design of multi-<br>scale anchors is a key component for sharing features<br>without extra cost for addressing scales.</p>",
            "id": 55,
            "page": 4,
            "text": "Because of this multi-scale design based on anchors, we can simply use the convolutional features computed on a single-scale image, as is also done by the Fast R-CNN detector . The design of multiscale anchors is a key component for sharing features without extra cost for addressing scales."
        },
        {
            "bounding_box": [
                {
                    "x": 1191,
                    "y": 2765
                },
                {
                    "x": 1595,
                    "y": 2765
                },
                {
                    "x": 1595,
                    "y": 2812
                },
                {
                    "x": 1191,
                    "y": 2812
                }
            ],
            "category": "paragraph",
            "html": "<p id='56' style='font-size:20px'>3.1.2 Loss Function</p>",
            "id": 56,
            "page": 4,
            "text": "3.1.2 Loss Function"
        },
        {
            "bounding_box": [
                {
                    "x": 1188,
                    "y": 2827
                },
                {
                    "x": 2196,
                    "y": 2827
                },
                {
                    "x": 2196,
                    "y": 3126
                },
                {
                    "x": 1188,
                    "y": 3126
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='57' style='font-size:20px'>For training RPNs, we assign a binary class label<br>(of being an object or not) to each anchor. We as-<br>sign a positive label to two kinds of anchors: (i) the<br>anchor / anchors with the highest Intersection-over-<br>Union (IoU) overlap with a ground-truth box, or (ii) an<br>anchor that has an IoU overlap higher than 0.7 with</p>",
            "id": 57,
            "page": 4,
            "text": "For training RPNs, we assign a binary class label (of being an object or not) to each anchor. We assign a positive label to two kinds of anchors: (i) the anchor / anchors with the highest Intersection-overUnion (IoU) overlap with a ground-truth box, or (ii) an anchor that has an IoU overlap higher than 0.7 with"
        },
        {
            "bounding_box": [
                {
                    "x": 2173,
                    "y": 122
                },
                {
                    "x": 2195,
                    "y": 122
                },
                {
                    "x": 2195,
                    "y": 148
                },
                {
                    "x": 2173,
                    "y": 148
                }
            ],
            "category": "header",
            "html": "<header id='58' style='font-size:14px'>5</header>",
            "id": 58,
            "page": 5,
            "text": "5"
        },
        {
            "bounding_box": [
                {
                    "x": 145,
                    "y": 235
                },
                {
                    "x": 1152,
                    "y": 235
                },
                {
                    "x": 1152,
                    "y": 730
                },
                {
                    "x": 145,
                    "y": 730
                }
            ],
            "category": "paragraph",
            "html": "<p id='59' style='font-size:14px'>any ground-truth box. Note that a single ground-truth<br>box may assign positive labels to multiple anchors.<br>Usually the second condition is sufficient to determine<br>the positive samples; but we still adopt the first<br>condition for the reason that in some rare cases the<br>second condition may find no positive sample. We<br>assign a negative label to a non-positive anchor if its<br>IoU ratio is lower than 0.3 for all ground-truth boxes.<br>Anchors that are neither positive nor negative do not<br>contribute to the training objective.</p>",
            "id": 59,
            "page": 5,
            "text": "any ground-truth box. Note that a single ground-truth box may assign positive labels to multiple anchors. Usually the second condition is sufficient to determine the positive samples; but we still adopt the first condition for the reason that in some rare cases the second condition may find no positive sample. We assign a negative label to a non-positive anchor if its IoU ratio is lower than 0.3 for all ground-truth boxes. Anchors that are neither positive nor negative do not contribute to the training objective."
        },
        {
            "bounding_box": [
                {
                    "x": 144,
                    "y": 738
                },
                {
                    "x": 1150,
                    "y": 738
                },
                {
                    "x": 1150,
                    "y": 882
                },
                {
                    "x": 144,
                    "y": 882
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='60' style='font-size:14px'>With these definitions, we minimize an objective<br>function following the multi-task loss in Fast R-CNN<br>[2]. Our loss function for an image is defined as:</p>",
            "id": 60,
            "page": 5,
            "text": "With these definitions, we minimize an objective function following the multi-task loss in Fast R-CNN . Our loss function for an image is defined as:"
        },
        {
            "bounding_box": [
                {
                    "x": 145,
                    "y": 1174
                },
                {
                    "x": 1153,
                    "y": 1174
                },
                {
                    "x": 1153,
                    "y": 1922
                },
                {
                    "x": 145,
                    "y": 1922
                }
            ],
            "category": "paragraph",
            "html": "<p id='61' style='font-size:16px'>Here, i is the index of an anchor in a mini-batch and<br>Pi is the predicted probability of anchor i being an<br>object. The ground-truth label p* is 1 if the anchor<br>is positive, and is 0 if the anchor is negative. ti is a<br>vector representing the 4 parameterized coordinates<br>of the predicted bounding box, and t* is that of the<br>ground-truth box associated with a positive anchor.<br>The classification loss Lcls is log loss over two classes<br>(object vs. not object). For the regression loss, we use<br>Lreg (ti, t*) = R(ti - t*) where R is the robust loss<br>function (smooth L1) defined in [2]. The term p*Lreg<br>means the regression loss is activated only for positive<br>anchors (P* = 1) and is disabled otherwise (P* = 0).<br>The outputs of the cls and reg layers consist of {Pi}<br>and {ti} respectively.</p>",
            "id": 61,
            "page": 5,
            "text": "Here, i is the index of an anchor in a mini-batch and Pi is the predicted probability of anchor i being an object. The ground-truth label p* is 1 if the anchor is positive, and is 0 if the anchor is negative. ti is a vector representing the 4 parameterized coordinates of the predicted bounding box, and t* is that of the ground-truth box associated with a positive anchor. The classification loss Lcls is log loss over two classes (object vs. not object). For the regression loss, we use Lreg (ti, t*) = R(ti - t*) where R is the robust loss function (smooth L1) defined in . The term p*Lreg means the regression loss is activated only for positive anchors (P* = 1) and is disabled otherwise (P* = 0). The outputs of the cls and reg layers consist of {Pi} and {ti} respectively."
        },
        {
            "bounding_box": [
                {
                    "x": 144,
                    "y": 1926
                },
                {
                    "x": 1153,
                    "y": 1926
                },
                {
                    "x": 1153,
                    "y": 2521
                },
                {
                    "x": 144,
                    "y": 2521
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='62' style='font-size:14px'>The two terms are normalized by Ncls and Nreg<br>and weighted by a balancing parameter 入. In our<br>current implementation (as in the released code), the<br>cls term in Eqn.(1) is normalized by the mini-batch<br>size (i.e., Ncls = 256) and the reg term is normalized<br>by the number of anchor locations (i.e., Nreg ~ 2, 400).<br>By default we set 入 = 10, and thus both cls and<br>reg terms are roughly equally weighted. We show<br>by experiments that the results are insensitive to the<br>values of 入 in a wide range (Table 9). We also note<br>that the normalization as above is not required and<br>could be simplified.</p>",
            "id": 62,
            "page": 5,
            "text": "The two terms are normalized by Ncls and Nreg and weighted by a balancing parameter 入. In our current implementation (as in the released code), the cls term in Eqn.(1) is normalized by the mini-batch size (i.e., Ncls = 256) and the reg term is normalized by the number of anchor locations (i.e., Nreg ~ 2, 400). By default we set 入 = 10, and thus both cls and reg terms are roughly equally weighted. We show by experiments that the results are insensitive to the values of 入 in a wide range (Table 9). We also note that the normalization as above is not required and could be simplified."
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 2525
                },
                {
                    "x": 1146,
                    "y": 2525
                },
                {
                    "x": 1146,
                    "y": 2621
                },
                {
                    "x": 143,
                    "y": 2621
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='63' style='font-size:18px'>For bounding box regression, we adopt the param-<br>eterizations of the 4 coordinates following [5]:</p>",
            "id": 63,
            "page": 5,
            "text": "For bounding box regression, we adopt the parameterizations of the 4 coordinates following :"
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 2927
                },
                {
                    "x": 1151,
                    "y": 2927
                },
                {
                    "x": 1151,
                    "y": 3126
                },
                {
                    "x": 143,
                    "y": 3126
                }
            ],
            "category": "paragraph",
            "html": "<p id='64' style='font-size:14px'>where x, y, w, and h denote the box's center coordi-<br>nates and its width and height. Variables x, xa, and<br>x* are for the predicted box, anchor box, and ground-<br>truth box respectively (likewise for y, w, h). This can</p>",
            "id": 64,
            "page": 5,
            "text": "where x, y, w, and h denote the box's center coordinates and its width and height. Variables x, xa, and x* are for the predicted box, anchor box, and groundtruth box respectively (likewise for y, w, h). This can"
        },
        {
            "bounding_box": [
                {
                    "x": 1188,
                    "y": 237
                },
                {
                    "x": 2193,
                    "y": 237
                },
                {
                    "x": 2193,
                    "y": 331
                },
                {
                    "x": 1188,
                    "y": 331
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='65' style='font-size:14px'>be thought of as bounding-box regression from an<br>anchor box to a nearby ground-truth box.</p>",
            "id": 65,
            "page": 5,
            "text": "be thought of as bounding-box regression from an anchor box to a nearby ground-truth box."
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 339
                },
                {
                    "x": 2199,
                    "y": 339
                },
                {
                    "x": 2199,
                    "y": 1033
                },
                {
                    "x": 1190,
                    "y": 1033
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='66' style='font-size:16px'>Nevertheless, our method achieves bounding-box<br>regression by a different manner from previous RoI-<br>based (Region of Interest) methods [1], [2]. In [1],<br>[2], bounding-box regression is performed on features<br>pooled from arbitrarily sized RoIs, and the regression<br>weights are shared by all region sizes. In our formula-<br>tion, the features used for regression are of the same<br>spatial size (3 x 3) on the feature maps. To account<br>for varying sizes, a set of k bounding-box regressors<br>are learned. Each regressor is responsible for one scale<br>and one aspect ratio, and the k regressors do not share<br>weights. As such, it is still possible to predict boxes of<br>various sizes even though the features are of a fixed<br>size/ scale, thanks to the design of anchors.</p>",
            "id": 66,
            "page": 5,
            "text": "Nevertheless, our method achieves bounding-box regression by a different manner from previous RoIbased (Region of Interest) methods , . In , , bounding-box regression is performed on features pooled from arbitrarily sized RoIs, and the regression weights are shared by all region sizes. In our formulation, the features used for regression are of the same spatial size (3 x 3) on the feature maps. To account for varying sizes, a set of k bounding-box regressors are learned. Each regressor is responsible for one scale and one aspect ratio, and the k regressors do not share weights. As such, it is still possible to predict boxes of various sizes even though the features are of a fixed size/ scale, thanks to the design of anchors."
        },
        {
            "bounding_box": [
                {
                    "x": 1191,
                    "y": 1083
                },
                {
                    "x": 1601,
                    "y": 1083
                },
                {
                    "x": 1601,
                    "y": 1129
                },
                {
                    "x": 1191,
                    "y": 1129
                }
            ],
            "category": "paragraph",
            "html": "<p id='67' style='font-size:20px'>3.1.3 Training RPNs</p>",
            "id": 67,
            "page": 5,
            "text": "3.1.3 Training RPNs"
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 1145
                },
                {
                    "x": 2198,
                    "y": 1145
                },
                {
                    "x": 2198,
                    "y": 1840
                },
                {
                    "x": 1190,
                    "y": 1840
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='68' style='font-size:16px'>The RPN can be trained end-to-end by back-<br>propagation and stochastic gradient descent (SGD)<br>[35]. We follow the \"image-centric\" sampling strategy<br>from [2] to train this network. Each mini-batch arises<br>from a single image that contains many positive and<br>negative example anchors. It is possible to optimize<br>for the loss functions of all anchors, but this will<br>bias towards negative samples as they are dominate.<br>Instead, we randomly sample 256 anchors in an image<br>to compute the loss function of a mini-batch, where<br>the sampled positive and negative anchors have a<br>ratio of up to 1:1. If there are fewer than 128 positive<br>samples in an image, we pad the mini-batch with<br>negative ones.</p>",
            "id": 68,
            "page": 5,
            "text": "The RPN can be trained end-to-end by backpropagation and stochastic gradient descent (SGD) . We follow the \"image-centric\" sampling strategy from  to train this network. Each mini-batch arises from a single image that contains many positive and negative example anchors. It is possible to optimize for the loss functions of all anchors, but this will bias towards negative samples as they are dominate. Instead, we randomly sample 256 anchors in an image to compute the loss function of a mini-batch, where the sampled positive and negative anchors have a ratio of up to 1:1. If there are fewer than 128 positive samples in an image, we pad the mini-batch with negative ones."
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 1844
                },
                {
                    "x": 2198,
                    "y": 1844
                },
                {
                    "x": 2198,
                    "y": 2441
                },
                {
                    "x": 1190,
                    "y": 2441
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='69' style='font-size:16px'>We randomly initialize all new layers by drawing<br>weights from a zero-mean Gaussian distribution with<br>standard deviation 0.01. All other layers (i.e., the<br>shared convolutional layers) are initialized by pre-<br>training a model for ImageNet classification [36], as<br>is standard practice [5]. We tune all layers of the<br>ZF net, and conv3_1 and up for the VGG net to<br>conserve memory [2]. We use a learning rate of 0.001<br>for 60k mini-batches, and 0.0001 for the next 20k<br>mini-batches on the PASCAL VOC dataset. We use a<br>momentum of 0.9 and a weight decay of 0.0005 [37].<br>Our implementation uses Caffe [38].</p>",
            "id": 69,
            "page": 5,
            "text": "We randomly initialize all new layers by drawing weights from a zero-mean Gaussian distribution with standard deviation 0.01. All other layers (i.e., the shared convolutional layers) are initialized by pretraining a model for ImageNet classification , as is standard practice . We tune all layers of the ZF net, and conv3_1 and up for the VGG net to conserve memory . We use a learning rate of 0.001 for 60k mini-batches, and 0.0001 for the next 20k mini-batches on the PASCAL VOC dataset. We use a momentum of 0.9 and a weight decay of 0.0005 . Our implementation uses Caffe ."
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 2510
                },
                {
                    "x": 2129,
                    "y": 2510
                },
                {
                    "x": 2129,
                    "y": 2556
                },
                {
                    "x": 1190,
                    "y": 2556
                }
            ],
            "category": "paragraph",
            "html": "<p id='70' style='font-size:20px'>3.2 Sharing Features for RPN and Fast R-CNN</p>",
            "id": 70,
            "page": 5,
            "text": "3.2 Sharing Features for RPN and Fast R-CNN"
        },
        {
            "bounding_box": [
                {
                    "x": 1189,
                    "y": 2577
                },
                {
                    "x": 2196,
                    "y": 2577
                },
                {
                    "x": 2196,
                    "y": 2922
                },
                {
                    "x": 1189,
                    "y": 2922
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='71' style='font-size:16px'>Thus far we have described how to train a network<br>for region proposal generation, without considering<br>the region-based object detection CNN that will utilize<br>these proposals. For the detection network, we adopt<br>Fast R-CNN [2]. Next we describe algorithms that<br>learn a unified network composed of RPN and Fast<br>R-CNN with shared convolutional layers (Figure 2).</p>",
            "id": 71,
            "page": 5,
            "text": "Thus far we have described how to train a network for region proposal generation, without considering the region-based object detection CNN that will utilize these proposals. For the detection network, we adopt Fast R-CNN . Next we describe algorithms that learn a unified network composed of RPN and Fast R-CNN with shared convolutional layers (Figure 2)."
        },
        {
            "bounding_box": [
                {
                    "x": 1188,
                    "y": 2926
                },
                {
                    "x": 2196,
                    "y": 2926
                },
                {
                    "x": 2196,
                    "y": 3128
                },
                {
                    "x": 1188,
                    "y": 3128
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='72' style='font-size:18px'>Both RPN and Fast R-CNN, trained independently,<br>will modify their convolutional layers in different<br>ways. We therefore need to develop a technique that<br>allows for sharing convolutional layers between the</p>",
            "id": 72,
            "page": 5,
            "text": "Both RPN and Fast R-CNN, trained independently, will modify their convolutional layers in different ways. We therefore need to develop a technique that allows for sharing convolutional layers between the"
        },
        {
            "bounding_box": [
                {
                    "x": 2168,
                    "y": 118
                },
                {
                    "x": 2199,
                    "y": 118
                },
                {
                    "x": 2199,
                    "y": 154
                },
                {
                    "x": 2168,
                    "y": 154
                }
            ],
            "category": "header",
            "html": "<header id='73' style='font-size:14px'>6</header>",
            "id": 73,
            "page": 6,
            "text": "6"
        },
        {
            "bounding_box": [
                {
                    "x": 241,
                    "y": 220
                },
                {
                    "x": 2096,
                    "y": 220
                },
                {
                    "x": 2096,
                    "y": 266
                },
                {
                    "x": 241,
                    "y": 266
                }
            ],
            "category": "paragraph",
            "html": "<p id='74' style='font-size:16px'>Table 1: the learned average proposal size for each anchor using the ZF net (numbers for s = 600).</p>",
            "id": 74,
            "page": 6,
            "text": "Table 1: the learned average proposal size for each anchor using the ZF net (numbers for s = 600)."
        },
        {
            "bounding_box": [
                {
                    "x": 250,
                    "y": 257
                },
                {
                    "x": 2066,
                    "y": 257
                },
                {
                    "x": 2066,
                    "y": 364
                },
                {
                    "x": 250,
                    "y": 364
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='75' style='font-size:20px'>anchor 1282, 2:1 1282, 1:1 1282, 1:2 2562, 2:1 2562, 1:1 2562, 1:2 5122, 2:1 5122, 1:1 5122, 1:2<br>proposal 188x111 113x114 70x92 416x229 261x284 174x332 768x437 499x501 355x715</p>",
            "id": 75,
            "page": 6,
            "text": "anchor 1282, 2:1 1282, 1:1 1282, 1:2 2562, 2:1 2562, 1:1 2562, 1:2 5122, 2:1 5122, 1:1 5122, 1:2 proposal 188x111 113x114 70x92 416x229 261x284 174x332 768x437 499x501 355x715"
        },
        {
            "bounding_box": [
                {
                    "x": 144,
                    "y": 491
                },
                {
                    "x": 1149,
                    "y": 491
                },
                {
                    "x": 1149,
                    "y": 632
                },
                {
                    "x": 144,
                    "y": 632
                }
            ],
            "category": "paragraph",
            "html": "<p id='76' style='font-size:18px'>two networks, rather than learning two separate net-<br>works. We discuss three ways for training networks<br>with features shared:</p>",
            "id": 76,
            "page": 6,
            "text": "two networks, rather than learning two separate networks. We discuss three ways for training networks with features shared:"
        },
        {
            "bounding_box": [
                {
                    "x": 144,
                    "y": 643
                },
                {
                    "x": 1151,
                    "y": 643
                },
                {
                    "x": 1151,
                    "y": 891
                },
                {
                    "x": 144,
                    "y": 891
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='77' style='font-size:16px'>(i) Alternating training. In this solution, we first train<br>RPN, and use the proposals to train Fast R-CNN.<br>The network tuned by Fast R-CNN is then used to<br>initialize RPN, and this process is iterated. This is the<br>solution that is used in all experiments in this paper.</p>",
            "id": 77,
            "page": 6,
            "text": "(i) Alternating training. In this solution, we first train RPN, and use the proposals to train Fast R-CNN. The network tuned by Fast R-CNN is then used to initialize RPN, and this process is iterated. This is the solution that is used in all experiments in this paper."
        },
        {
            "bounding_box": [
                {
                    "x": 145,
                    "y": 902
                },
                {
                    "x": 1152,
                    "y": 902
                },
                {
                    "x": 1152,
                    "y": 1744
                },
                {
                    "x": 145,
                    "y": 1744
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='78' style='font-size:18px'>(ii) Approximate joint training. In this solution, the<br>RPN and Fast R-CNN networks are merged into one<br>network during training as in Figure 2. In each SGD<br>iteration, the forward pass generates region propos-<br>als which are treated just like fixed, pre-computed<br>proposals when training a Fast R-CNN detector. The<br>backward propagation takes place as usual, where for<br>the shared layers the backward propagated signals<br>from both the RPN loss and the Fast R-CNN loss<br>are combined. This solution is easy to implement. But<br>this solution ignores the derivative w.r.t. the proposal<br>boxes' coordinates that are also network responses,<br>SO is approximate. In our experiments, we have em-<br>pirically found this solver produces close results, yet<br>reduces the training time by about 25-50% comparing<br>with alternating training. This solver is included in<br>our released Python code.</p>",
            "id": 78,
            "page": 6,
            "text": "(ii) Approximate joint training. In this solution, the RPN and Fast R-CNN networks are merged into one network during training as in Figure 2. In each SGD iteration, the forward pass generates region proposals which are treated just like fixed, pre-computed proposals when training a Fast R-CNN detector. The backward propagation takes place as usual, where for the shared layers the backward propagated signals from both the RPN loss and the Fast R-CNN loss are combined. This solution is easy to implement. But this solution ignores the derivative w.r.t. the proposal boxes' coordinates that are also network responses, SO is approximate. In our experiments, we have empirically found this solver produces close results, yet reduces the training time by about 25-50% comparing with alternating training. This solver is included in our released Python code."
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 1754
                },
                {
                    "x": 1152,
                    "y": 1754
                },
                {
                    "x": 1152,
                    "y": 2450
                },
                {
                    "x": 143,
                    "y": 2450
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='79' style='font-size:20px'>(iii) Non-approximate joint training. As discussed<br>above, the bounding boxes predicted by RPN are<br>also functions of the input. The RoI pooling layer<br>[2] in Fast R-CNN accepts the convolutional features<br>and also the predicted bounding boxes as input, so<br>a theoretically valid backpropagation solver should<br>also involve gradients w.r.t. the box coordinates. These<br>gradients are ignored in the above approximate joint<br>training. In a non-approximate joint training solution,<br>we need an RoI pooling layer that is differentiable<br>w.r.t. the box coordinates. This is a nontrivial problem<br>and a solution can be given by an \"RoI warping\" layer<br>as developed in [15], which is beyond the scope of this<br>paper.</p>",
            "id": 79,
            "page": 6,
            "text": "(iii) Non-approximate joint training. As discussed above, the bounding boxes predicted by RPN are also functions of the input. The RoI pooling layer  in Fast R-CNN accepts the convolutional features and also the predicted bounding boxes as input, so a theoretically valid backpropagation solver should also involve gradients w.r.t. the box coordinates. These gradients are ignored in the above approximate joint training. In a non-approximate joint training solution, we need an RoI pooling layer that is differentiable w.r.t. the box coordinates. This is a nontrivial problem and a solution can be given by an \"RoI warping\" layer as developed in , which is beyond the scope of this paper."
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 2477
                },
                {
                    "x": 1152,
                    "y": 2477
                },
                {
                    "x": 1152,
                    "y": 3126
                },
                {
                    "x": 143,
                    "y": 3126
                }
            ],
            "category": "paragraph",
            "html": "<p id='80' style='font-size:18px'>4-Step Alternating Training. In this paper, we adopt<br>a pragmatic 4-step training algorithm to learn shared<br>features via alternating optimization. In the first step,<br>we train the RPN as described in Section 3.1.3. This<br>network is initialized with an ImageNet-pre-trained<br>model and fine-tuned end-to-end for the region pro-<br>posal task. In the second step, we train a separate<br>detection network by Fast R-CNN using the proposals<br>generated by the step-1 RPN. This detection net-<br>work is also initialized by the ImageNet-pre-trained<br>model. At this point the two networks do not share<br>convolutional layers. In the third step, we use the<br>detector network to initialize RPN training, but we</p>",
            "id": 80,
            "page": 6,
            "text": "4-Step Alternating Training. In this paper, we adopt a pragmatic 4-step training algorithm to learn shared features via alternating optimization. In the first step, we train the RPN as described in Section 3.1.3. This network is initialized with an ImageNet-pre-trained model and fine-tuned end-to-end for the region proposal task. In the second step, we train a separate detection network by Fast R-CNN using the proposals generated by the step-1 RPN. This detection network is also initialized by the ImageNet-pre-trained model. At this point the two networks do not share convolutional layers. In the third step, we use the detector network to initialize RPN training, but we"
        },
        {
            "bounding_box": [
                {
                    "x": 1191,
                    "y": 488
                },
                {
                    "x": 2197,
                    "y": 488
                },
                {
                    "x": 2197,
                    "y": 934
                },
                {
                    "x": 1191,
                    "y": 934
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='81' style='font-size:18px'>fix the shared convolutional layers and only fine-tune<br>the layers unique to RPN. Now the two networks<br>share convolutional layers. Finally, keeping the shared<br>convolutional layers fixed, we fine-tune the unique<br>layers of Fast R-CNN. As such, both networks share<br>the same convolutional layers and form a unified<br>network. A similar alternating training can be run<br>for more iterations, but we have observed negligible<br>improvements.</p>",
            "id": 81,
            "page": 6,
            "text": "fix the shared convolutional layers and only fine-tune the layers unique to RPN. Now the two networks share convolutional layers. Finally, keeping the shared convolutional layers fixed, we fine-tune the unique layers of Fast R-CNN. As such, both networks share the same convolutional layers and form a unified network. A similar alternating training can be run for more iterations, but we have observed negligible improvements."
        },
        {
            "bounding_box": [
                {
                    "x": 1187,
                    "y": 973
                },
                {
                    "x": 1752,
                    "y": 973
                },
                {
                    "x": 1752,
                    "y": 1020
                },
                {
                    "x": 1187,
                    "y": 1020
                }
            ],
            "category": "paragraph",
            "html": "<p id='82' style='font-size:22px'>3.3 Implementation Details</p>",
            "id": 82,
            "page": 6,
            "text": "3.3 Implementation Details"
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 1036
                },
                {
                    "x": 2197,
                    "y": 1036
                },
                {
                    "x": 2197,
                    "y": 1629
                },
                {
                    "x": 1190,
                    "y": 1629
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='83' style='font-size:18px'>We train and test both region proposal and object<br>detection networks on images of a single scale [1], [2].<br>We re-scale the images such that their shorter side<br>is s = 600 pixels [2]. Multi-scale feature extraction<br>(using an image pyramid) may improve accuracy but<br>does not exhibit a good speed-accuracy trade-off [2].<br>On the re-scaled images, the total stride for both ZF<br>and VGG nets on the last convolutional layer is 16<br>pixels, and thus is ~10 pixels on a typical PASCAL<br>image before resizing (~500x375). Even such a large<br>stride provides good results, though accuracy may be<br>further improved with a smaller stride.</p>",
            "id": 83,
            "page": 6,
            "text": "We train and test both region proposal and object detection networks on images of a single scale , . We re-scale the images such that their shorter side is s = 600 pixels . Multi-scale feature extraction (using an image pyramid) may improve accuracy but does not exhibit a good speed-accuracy trade-off . On the re-scaled images, the total stride for both ZF and VGG nets on the last convolutional layer is 16 pixels, and thus is ~10 pixels on a typical PASCAL image before resizing (~500x375). Even such a large stride provides good results, though accuracy may be further improved with a smaller stride."
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 1632
                },
                {
                    "x": 2198,
                    "y": 1632
                },
                {
                    "x": 2198,
                    "y": 2426
                },
                {
                    "x": 1190,
                    "y": 2426
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='84' style='font-size:18px'>For anchors, we use 3 scales with box areas of 1282,<br>2562, and 5122 pixels, and 3 aspect ratios of 1:1, 1:2,<br>and 2:1. These hyper-parameters are not carefully cho-<br>sen for a particular dataset, and we provide ablation<br>experiments on their effects in the next section. As dis-<br>cussed, our solution does not need an image pyramid<br>or filter pyramid to predict regions of multiple scales,<br>saving considerable running time. Figure 3 (right)<br>shows the capability of our method for a wide range<br>of scales and aspect ratios. Table 1 shows the learned<br>average proposal size for each anchor using the ZF<br>net. We note that our algorithm allows predictions<br>that are larger than the underlying receptive field.<br>Such predictions are not impossible-one may still<br>roughly infer the extent of an object if only the middle<br>of the object is visible.</p>",
            "id": 84,
            "page": 6,
            "text": "For anchors, we use 3 scales with box areas of 1282, 2562, and 5122 pixels, and 3 aspect ratios of 1:1, 1:2, and 2:1. These hyper-parameters are not carefully chosen for a particular dataset, and we provide ablation experiments on their effects in the next section. As discussed, our solution does not need an image pyramid or filter pyramid to predict regions of multiple scales, saving considerable running time. Figure 3 (right) shows the capability of our method for a wide range of scales and aspect ratios. Table 1 shows the learned average proposal size for each anchor using the ZF net. We note that our algorithm allows predictions that are larger than the underlying receptive field. Such predictions are not impossible-one may still roughly infer the extent of an object if only the middle of the object is visible."
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 2429
                },
                {
                    "x": 2198,
                    "y": 2429
                },
                {
                    "x": 2198,
                    "y": 3125
                },
                {
                    "x": 1190,
                    "y": 3125
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='85' style='font-size:18px'>The anchor boxes that cross image boundaries need<br>to be handled with care. During training, we ignore<br>all cross-boundary anchors so they do not contribute<br>to the loss. For a typical 1000 x 600 image, there<br>will be roughly 20000 (2 60 x 40 x 9) anchors in<br>total. With the cross-boundary anchors ignored, there<br>are about 6000 anchors per image for training. If the<br>boundary-crossing outliers are not ignored in training,<br>they introduce large, difficult to correct error terms in<br>the objective, and training does not converge. During<br>testing, however, we still apply the fully convolutional<br>RPN to the entire image. This may generate cross-<br>boundary proposal boxes, which we clip to the image<br>boundary.</p>",
            "id": 85,
            "page": 6,
            "text": "The anchor boxes that cross image boundaries need to be handled with care. During training, we ignore all cross-boundary anchors so they do not contribute to the loss. For a typical 1000 x 600 image, there will be roughly 20000 (2 60 x 40 x 9) anchors in total. With the cross-boundary anchors ignored, there are about 6000 anchors per image for training. If the boundary-crossing outliers are not ignored in training, they introduce large, difficult to correct error terms in the objective, and training does not converge. During testing, however, we still apply the fully convolutional RPN to the entire image. This may generate crossboundary proposal boxes, which we clip to the image boundary."
        },
        {
            "bounding_box": [
                {
                    "x": 2168,
                    "y": 117
                },
                {
                    "x": 2199,
                    "y": 117
                },
                {
                    "x": 2199,
                    "y": 153
                },
                {
                    "x": 2168,
                    "y": 153
                }
            ],
            "category": "header",
            "html": "<header id='86' style='font-size:14px'>7</header>",
            "id": 86,
            "page": 7,
            "text": "7"
        },
        {
            "bounding_box": [
                {
                    "x": 141,
                    "y": 219
                },
                {
                    "x": 2196,
                    "y": 219
                },
                {
                    "x": 2196,
                    "y": 315
                },
                {
                    "x": 141,
                    "y": 315
                }
            ],
            "category": "caption",
            "html": "<caption id='87' style='font-size:18px'>Table 2: Detection results on PASCAL VOC 2007 test set (trained on VOC 2007 trainval). The detectors are<br>Fast R-CNN with ZF, but using various proposal methods for training and testing.</caption>",
            "id": 87,
            "page": 7,
            "text": "Table 2: Detection results on PASCAL VOC 2007 test set (trained on VOC 2007 trainval). The detectors are Fast R-CNN with ZF, but using various proposal methods for training and testing."
        },
        {
            "bounding_box": [
                {
                    "x": 431,
                    "y": 324
                },
                {
                    "x": 1899,
                    "y": 324
                },
                {
                    "x": 1899,
                    "y": 1145
                },
                {
                    "x": 431,
                    "y": 1145
                }
            ],
            "category": "table",
            "html": "<br><table id='88' style='font-size:16px'><tr><td rowspan=\"2\">train-time region proposals method</td><td rowspan=\"2\"># boxes</td><td colspan=\"2\">test-time region proposals</td><td rowspan=\"2\">mAP (%)</td></tr><tr><td>method</td><td># proposals</td></tr><tr><td>SS</td><td>2000</td><td>SS</td><td>2000</td><td>58.7</td></tr><tr><td>EB</td><td>2000</td><td>EB</td><td>2000</td><td>58.6</td></tr><tr><td>RPN+ZF, shared</td><td>2000</td><td>RPN+ZF, shared</td><td>300</td><td>59.9</td></tr><tr><td colspan=\"5\">ablation experiments follow below</td></tr><tr><td>RPN+ZF, unshared</td><td>2000</td><td>RPN+ZF, unshared</td><td>300</td><td>58.7</td></tr><tr><td>SS</td><td>2000</td><td>RPN+ZF</td><td>100</td><td>55.1</td></tr><tr><td>SS</td><td>2000</td><td>RPN+ZF</td><td>300</td><td>56.8</td></tr><tr><td>SS</td><td>2000</td><td>RPN+ZF</td><td>1000</td><td>56.3</td></tr><tr><td>SS</td><td>2000</td><td>RPN+ZF (no NMS)</td><td>6000</td><td>55.2</td></tr><tr><td>SS</td><td>2000</td><td>RPN+ZF (no cls)</td><td>100</td><td>44.6</td></tr><tr><td>SS</td><td>2000</td><td>RPN+ZF (no cls)</td><td>300</td><td>51.4</td></tr><tr><td>SS</td><td>2000</td><td>RPN+ZF (no cls)</td><td>1000</td><td>55.8</td></tr><tr><td>SS</td><td>2000</td><td>RPN+ZF (no reg)</td><td>300</td><td>52.1</td></tr><tr><td>SS</td><td>2000</td><td>RPN+ZF (no reg)</td><td>1000</td><td>51.3</td></tr><tr><td>SS</td><td>2000</td><td>RPN+VGG</td><td>300</td><td>59.2</td></tr></table>",
            "id": 88,
            "page": 7,
            "text": "train-time region proposals method # boxes test-time region proposals mAP (%)  method # proposals  SS 2000 SS 2000 58.7  EB 2000 EB 2000 58.6  RPN+ZF, shared 2000 RPN+ZF, shared 300 59.9  ablation experiments follow below  RPN+ZF, unshared 2000 RPN+ZF, unshared 300 58.7  SS 2000 RPN+ZF 100 55.1  SS 2000 RPN+ZF 300 56.8  SS 2000 RPN+ZF 1000 56.3  SS 2000 RPN+ZF (no NMS) 6000 55.2  SS 2000 RPN+ZF (no cls) 100 44.6  SS 2000 RPN+ZF (no cls) 300 51.4  SS 2000 RPN+ZF (no cls) 1000 55.8  SS 2000 RPN+ZF (no reg) 300 52.1  SS 2000 RPN+ZF (no reg) 1000 51.3  SS 2000 RPN+VGG 300"
        },
        {
            "bounding_box": [
                {
                    "x": 145,
                    "y": 1260
                },
                {
                    "x": 1154,
                    "y": 1260
                },
                {
                    "x": 1154,
                    "y": 1857
                },
                {
                    "x": 145,
                    "y": 1857
                }
            ],
            "category": "paragraph",
            "html": "<p id='89' style='font-size:18px'>Some RPN proposals highly overlap with each<br>other. To reduce redundancy, we adopt non-maximum<br>suppression (NMS) on the proposal regions based on<br>their cls scores. We fix the IoU threshold for NMS<br>at 0.7, which leaves us about 2000 proposal regions<br>per image. As we will show, NMS does not harm the<br>ultimate detection accuracy, but substantially reduces<br>the number of proposals. After NMS, we use the<br>top-N ranked proposal regions for detection. In the<br>following, we train Fast R-CNN using 2000 RPN pro-<br>posals, but evaluate different numbers of proposals at<br>test-time.</p>",
            "id": 89,
            "page": 7,
            "text": "Some RPN proposals highly overlap with each other. To reduce redundancy, we adopt non-maximum suppression (NMS) on the proposal regions based on their cls scores. We fix the IoU threshold for NMS at 0.7, which leaves us about 2000 proposal regions per image. As we will show, NMS does not harm the ultimate detection accuracy, but substantially reduces the number of proposals. After NMS, we use the top-N ranked proposal regions for detection. In the following, we train Fast R-CNN using 2000 RPN proposals, but evaluate different numbers of proposals at test-time."
        },
        {
            "bounding_box": [
                {
                    "x": 146,
                    "y": 1912
                },
                {
                    "x": 552,
                    "y": 1912
                },
                {
                    "x": 552,
                    "y": 1963
                },
                {
                    "x": 146,
                    "y": 1963
                }
            ],
            "category": "paragraph",
            "html": "<p id='90' style='font-size:22px'>4 EXPERIMENTS</p>",
            "id": 90,
            "page": 7,
            "text": "4 EXPERIMENTS"
        },
        {
            "bounding_box": [
                {
                    "x": 145,
                    "y": 1982
                },
                {
                    "x": 843,
                    "y": 1982
                },
                {
                    "x": 843,
                    "y": 2027
                },
                {
                    "x": 145,
                    "y": 2027
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='91' style='font-size:20px'>4.1 Experiments on PASCAL VOC</p>",
            "id": 91,
            "page": 7,
            "text": "4.1 Experiments on PASCAL VOC"
        },
        {
            "bounding_box": [
                {
                    "x": 144,
                    "y": 2046
                },
                {
                    "x": 1154,
                    "y": 2046
                },
                {
                    "x": 1154,
                    "y": 2741
                },
                {
                    "x": 144,
                    "y": 2741
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='92' style='font-size:18px'>We comprehensively evaluate our method on the<br>PASCAL VOC 2007 detection benchmark [11]. This<br>dataset consists of about 5k trainval images and 5k<br>test images over 20 object categories. We also provide<br>results on the PASCAL VOC 2012 benchmark for a<br>few models. For the ImageNet pre-trained network,<br>we use the \"fast\" version of ZF net [32] that has<br>5 convolutional layers and 3 fully-connected layers,<br>and the public VGG-16 model7 [3] that has 13 con-<br>volutional layers and 3 fully-connected layers. We<br>primarily evaluate detection mean Average Precision<br>(mAP), because this is the actual metric for object<br>detection (rather than focusing on object proposal<br>proxy metrics).</p>",
            "id": 92,
            "page": 7,
            "text": "We comprehensively evaluate our method on the PASCAL VOC 2007 detection benchmark . This dataset consists of about 5k trainval images and 5k test images over 20 object categories. We also provide results on the PASCAL VOC 2012 benchmark for a few models. For the ImageNet pre-trained network, we use the \"fast\" version of ZF net  that has 5 convolutional layers and 3 fully-connected layers, and the public VGG-16 model7  that has 13 convolutional layers and 3 fully-connected layers. We primarily evaluate detection mean Average Precision (mAP), because this is the actual metric for object detection (rather than focusing on object proposal proxy metrics)."
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 2743
                },
                {
                    "x": 1153,
                    "y": 2743
                },
                {
                    "x": 1153,
                    "y": 3043
                },
                {
                    "x": 143,
                    "y": 3043
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='93' style='font-size:18px'>Table 2 (top) shows Fast R-CNN results when<br>trained and tested using various region proposal<br>methods. These results use the ZF net. For Selective<br>Search (SS) [4], we generate about 2000 proposals by<br>the \"fast\" mode. For EdgeBoxes (EB) [6], we generate<br>the proposals by the default EB setting tuned for 0.7</p>",
            "id": 93,
            "page": 7,
            "text": "Table 2 (top) shows Fast R-CNN results when trained and tested using various region proposal methods. These results use the ZF net. For Selective Search (SS) , we generate about 2000 proposals by the \"fast\" mode. For EdgeBoxes (EB) , we generate the proposals by the default EB setting tuned for 0.7"
        },
        {
            "bounding_box": [
                {
                    "x": 177,
                    "y": 3081
                },
                {
                    "x": 966,
                    "y": 3081
                },
                {
                    "x": 966,
                    "y": 3122
                },
                {
                    "x": 177,
                    "y": 3122
                }
            ],
            "category": "paragraph",
            "html": "<p id='94' style='font-size:16px'>7. www.robots.ox.ac.uk/ ~vgg/research/ very_deep/</p>",
            "id": 94,
            "page": 7,
            "text": "7. www.robots.ox.ac.uk/ ~vgg/research/ very_deep/"
        },
        {
            "bounding_box": [
                {
                    "x": 1187,
                    "y": 1261
                },
                {
                    "x": 2198,
                    "y": 1261
                },
                {
                    "x": 2198,
                    "y": 1662
                },
                {
                    "x": 1187,
                    "y": 1662
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='95' style='font-size:18px'>IoU. SS has an mAP of 58.7% and EB has an mAP<br>of 58.6% under the Fast R-CNN framework. RPN<br>with Fast R-CNN achieves competitive results, with<br>an mAP of 59.9% while using up to 300 proposals8.<br>Using RPN yields a much faster detection system than<br>using either SS or EB because of shared convolutional<br>computations; the fewer proposals also reduce the<br>region-wise fully-connected layers' cost (Table 5).</p>",
            "id": 95,
            "page": 7,
            "text": "IoU. SS has an mAP of 58.7% and EB has an mAP of 58.6% under the Fast R-CNN framework. RPN with Fast R-CNN achieves competitive results, with an mAP of 59.9% while using up to 300 proposals8. Using RPN yields a much faster detection system than using either SS or EB because of shared convolutional computations; the fewer proposals also reduce the region-wise fully-connected layers' cost (Table 5)."
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 1679
                },
                {
                    "x": 2198,
                    "y": 1679
                },
                {
                    "x": 2198,
                    "y": 2228
                },
                {
                    "x": 1190,
                    "y": 2228
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='96' style='font-size:18px'>Ablation Experiments on RPN. To investigate the be-<br>havior of RPNs as a proposal method, we conducted<br>several ablation studies. First, we show the effect of<br>sharing convolutional layers between the RPN and<br>Fast R-CNN detection network. To do this, we stop<br>after the second step in the 4-step training process.<br>Using separate networks reduces the result slightly to<br>58.7% (RPN+ZF, unshared, Table 2). We observe that<br>this is because in the third step when the detector-<br>tuned features are used to fine-tune the RPN, the<br>proposal quality is improved.</p>",
            "id": 96,
            "page": 7,
            "text": "Ablation Experiments on RPN. To investigate the behavior of RPNs as a proposal method, we conducted several ablation studies. First, we show the effect of sharing convolutional layers between the RPN and Fast R-CNN detection network. To do this, we stop after the second step in the 4-step training process. Using separate networks reduces the result slightly to 58.7% (RPN+ZF, unshared, Table 2). We observe that this is because in the third step when the detectortuned features are used to fine-tune the RPN, the proposal quality is improved."
        },
        {
            "bounding_box": [
                {
                    "x": 1188,
                    "y": 2228
                },
                {
                    "x": 2198,
                    "y": 2228
                },
                {
                    "x": 2198,
                    "y": 2620
                },
                {
                    "x": 1188,
                    "y": 2620
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='97' style='font-size:18px'>Next, we disentangle the RPN's influence on train-<br>ing the Fast R-CNN detection network. For this pur-<br>pose, we train a Fast R-CNN model by using the<br>2000 SS proposals and ZF net. We fix this detector<br>and evaluate the detection mAP by changing the<br>proposal regions used at test-time. In these ablation<br>experiments, the RPN does not share features with<br>the detector.</p>",
            "id": 97,
            "page": 7,
            "text": "Next, we disentangle the RPN's influence on training the Fast R-CNN detection network. For this purpose, we train a Fast R-CNN model by using the 2000 SS proposals and ZF net. We fix this detector and evaluate the detection mAP by changing the proposal regions used at test-time. In these ablation experiments, the RPN does not share features with the detector."
        },
        {
            "bounding_box": [
                {
                    "x": 1188,
                    "y": 2625
                },
                {
                    "x": 2197,
                    "y": 2625
                },
                {
                    "x": 2197,
                    "y": 2868
                },
                {
                    "x": 1188,
                    "y": 2868
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='98' style='font-size:18px'>Replacing SS with 300 RPN proposals at test-time<br>leads to an mAP of 56.8%. The loss in mAP is because<br>of the inconsistency between the training/ testing pro-<br>posals. This result serves as the baseline for the fol-<br>lowing comparisons.</p>",
            "id": 98,
            "page": 7,
            "text": "Replacing SS with 300 RPN proposals at test-time leads to an mAP of 56.8%. The loss in mAP is because of the inconsistency between the training/ testing proposals. This result serves as the baseline for the following comparisons."
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 2874
                },
                {
                    "x": 2196,
                    "y": 2874
                },
                {
                    "x": 2196,
                    "y": 2968
                },
                {
                    "x": 1190,
                    "y": 2968
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='99' style='font-size:20px'>Somewhat surprisingly, the RPN still leads to a<br>competitive result (55.1 %) when using the top-ranked</p>",
            "id": 99,
            "page": 7,
            "text": "Somewhat surprisingly, the RPN still leads to a competitive result (55.1 %) when using the top-ranked"
        },
        {
            "bounding_box": [
                {
                    "x": 1188,
                    "y": 3006
                },
                {
                    "x": 2197,
                    "y": 3006
                },
                {
                    "x": 2197,
                    "y": 3122
                },
                {
                    "x": 1188,
                    "y": 3122
                }
            ],
            "category": "paragraph",
            "html": "<p id='100' style='font-size:14px'>8. For RPN, the number of proposals (e.g., 300) is the maximum<br>number for an image. RPN may produce fewer proposals after<br>NMS, and thus the average number of proposals is smaller.</p>",
            "id": 100,
            "page": 7,
            "text": "8. For RPN, the number of proposals (e.g., 300) is the maximum number for an image. RPN may produce fewer proposals after NMS, and thus the average number of proposals is smaller."
        },
        {
            "bounding_box": [
                {
                    "x": 2172,
                    "y": 122
                },
                {
                    "x": 2195,
                    "y": 122
                },
                {
                    "x": 2195,
                    "y": 149
                },
                {
                    "x": 2172,
                    "y": 149
                }
            ],
            "category": "header",
            "html": "<header id='101' style='font-size:14px'>8</header>",
            "id": 101,
            "page": 8,
            "text": "8"
        },
        {
            "bounding_box": [
                {
                    "x": 140,
                    "y": 217
                },
                {
                    "x": 2199,
                    "y": 217
                },
                {
                    "x": 2199,
                    "y": 420
                },
                {
                    "x": 140,
                    "y": 420
                }
            ],
            "category": "paragraph",
            "html": "<p id='102' style='font-size:18px'>Table 3: Detection results on PASCAL VOC 2007 test set. The detector is Fast R-CNN and VGG-16. Training<br>data: \"07\": VOC 2007 trainval, \"07+12\": union set of VOC 2007 trainval and VOC 2012 trainval. For RPN,<br>the train-time proposals for Fast R-CNN are 2000. t: this number was reported in [2]; using the repository<br>provided by this paper, this result is higher (68.1).</p>",
            "id": 102,
            "page": 8,
            "text": "Table 3: Detection results on PASCAL VOC 2007 test set. The detector is Fast R-CNN and VGG-16. Training data: \"07\": VOC 2007 trainval, \"07+12\": union set of VOC 2007 trainval and VOC 2012 trainval. For RPN, the train-time proposals for Fast R-CNN are 2000. t: this number was reported in ; using the repository provided by this paper, this result is higher (68.1)."
        },
        {
            "bounding_box": [
                {
                    "x": 519,
                    "y": 417
                },
                {
                    "x": 1812,
                    "y": 417
                },
                {
                    "x": 1812,
                    "y": 759
                },
                {
                    "x": 519,
                    "y": 759
                }
            ],
            "category": "table",
            "html": "<br><table id='103' style='font-size:16px'><tr><td>method</td><td># proposals</td><td>data</td><td>mAP (%)</td></tr><tr><td>SS</td><td>2000</td><td>07</td><td>66.9T</td></tr><tr><td>SS</td><td>2000</td><td>07+12</td><td>70.0</td></tr><tr><td>RPN+VGG, unshared</td><td>300</td><td>07</td><td>68.5</td></tr><tr><td>RPN+VGG, shared</td><td>300</td><td>07</td><td>69.9</td></tr><tr><td>RPN+VGG, shared</td><td>300</td><td>07+12</td><td>73.2</td></tr><tr><td>RPN+VGG, shared</td><td>300</td><td>COCO+07+12</td><td>78.8</td></tr></table>",
            "id": 103,
            "page": 8,
            "text": "method # proposals data mAP (%)  SS 2000 07 66.9T  SS 2000 07+12 70.0  RPN+VGG, unshared 300 07 68.5  RPN+VGG, shared 300 07 69.9  RPN+VGG, shared 300 07+12 73.2  RPN+VGG, shared 300 COCO+07+12"
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 826
                },
                {
                    "x": 2200,
                    "y": 826
                },
                {
                    "x": 2200,
                    "y": 1003
                },
                {
                    "x": 143,
                    "y": 1003
                }
            ],
            "category": "caption",
            "html": "<caption id='104' style='font-size:18px'>Table 4: Detection results on PASCAL VOC 2012 test set. The detector is Fast R-CNN and VGG-16. Training<br>data: \"07\" : VOC 2007 trainval, \"07++12\": union set of VOC 2007 trainval+test and VOC 2012 trainval. For<br>RPN, the train-time proposals for Fast R-CNN are 2000. 1: http:/ /postp/iots.comatic2080/anonpous/H2jT@4.html 1:<br>http:/ /host.robots.ox.ac.uk:8080/ anonymous/YNPLXB.html. §: http:/ / host.robots.ox.ac.uk:8080/ anonymous/XEDH10.html.</caption>",
            "id": 104,
            "page": 8,
            "text": "Table 4: Detection results on PASCAL VOC 2012 test set. The detector is Fast R-CNN and VGG-16. Training data: \"07\" : VOC 2007 trainval, \"07++12\": union set of VOC 2007 trainval+test and VOC 2012 trainval. For RPN, the train-time proposals for Fast R-CNN are 2000. 1: http:/ /postp/iots.comatic2080/anonpous/H2jT@4.html 1: http:/ /host.robots.ox.ac.uk:8080/ anonymous/YNPLXB.html. §: http:/ / host.robots.ox.ac.uk:8080/ anonymous/XEDH10.html."
        },
        {
            "bounding_box": [
                {
                    "x": 521,
                    "y": 1000
                },
                {
                    "x": 1806,
                    "y": 1000
                },
                {
                    "x": 1806,
                    "y": 1303
                },
                {
                    "x": 521,
                    "y": 1303
                }
            ],
            "category": "table",
            "html": "<br><table id='105' style='font-size:14px'><tr><td>method</td><td># proposals</td><td>data</td><td>mAP (%)</td></tr><tr><td>SS</td><td>2000</td><td>12</td><td>65.7</td></tr><tr><td>SS</td><td>2000</td><td>07++12</td><td>68.4</td></tr><tr><td>RPN+VGG, shared†</td><td>300</td><td>12</td><td>67.0</td></tr><tr><td>RPN+VGG, shared‡</td><td>300</td><td>07++12</td><td>70.4</td></tr><tr><td>RPN+VGG, shared s</td><td>300</td><td>COCO+07++12</td><td>75.9</td></tr></table>",
            "id": 105,
            "page": 8,
            "text": "method # proposals data mAP (%)  SS 2000 12 65.7  SS 2000 07++12 68.4  RPN+VGG, shared† 300 12 67.0  RPN+VGG, shared‡ 300 07++12 70.4  RPN+VGG, shared s 300 COCO+07++12"
        },
        {
            "bounding_box": [
                {
                    "x": 142,
                    "y": 1369
                },
                {
                    "x": 2196,
                    "y": 1369
                },
                {
                    "x": 2196,
                    "y": 1468
                },
                {
                    "x": 142,
                    "y": 1468
                }
            ],
            "category": "caption",
            "html": "<caption id='106' style='font-size:22px'>Table 5: Timing (ms) on a K40 GPU, except SS proposal is evaluated in a CPU. \"Region-wise\" includes NMS,<br>pooling, fully-connected, and softmax layers. See our released code for the profiling of running time.</caption>",
            "id": 106,
            "page": 8,
            "text": "Table 5: Timing (ms) on a K40 GPU, except SS proposal is evaluated in a CPU. \"Region-wise\" includes NMS, pooling, fully-connected, and softmax layers. See our released code for the profiling of running time."
        },
        {
            "bounding_box": [
                {
                    "x": 338,
                    "y": 1467
                },
                {
                    "x": 1985,
                    "y": 1467
                },
                {
                    "x": 1985,
                    "y": 1673
                },
                {
                    "x": 338,
                    "y": 1673
                }
            ],
            "category": "table",
            "html": "<br><table id='107' style='font-size:14px'><tr><td>model</td><td>system</td><td>conv</td><td>proposal</td><td>region-wise</td><td>total</td><td>rate</td></tr><tr><td rowspan=\"2\">VGG VGG</td><td>SS + Fast R-CNN</td><td>146</td><td>1510</td><td>174</td><td>1830</td><td>0.5 fps</td></tr><tr><td>RPN + Fast R-CNN</td><td>141</td><td>10</td><td>47</td><td>198</td><td>5 fps</td></tr><tr><td>ZF</td><td>RPN + Fast R-CNN</td><td>31</td><td>3</td><td>25</td><td>59</td><td>17 fps</td></tr></table>",
            "id": 107,
            "page": 8,
            "text": "model system conv proposal region-wise total rate  VGG VGG SS + Fast R-CNN 146 1510 174 1830 0.5 fps  RPN + Fast R-CNN 141 10 47 198 5 fps  ZF RPN + Fast R-CNN 31 3 25 59"
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 1790
                },
                {
                    "x": 1150,
                    "y": 1790
                },
                {
                    "x": 1150,
                    "y": 2088
                },
                {
                    "x": 143,
                    "y": 2088
                }
            ],
            "category": "paragraph",
            "html": "<p id='108' style='font-size:20px'>100 proposals at test-time, indicating that the top-<br>ranked RPN proposals are accurate. On the other<br>extreme, using the top-ranked 6000 RPN proposals<br>(without NMS) has a comparable mAP (55.2%), sug-<br>gesting NMS does not harm the detection mAP and<br>may reduce false alarms.</p>",
            "id": 108,
            "page": 8,
            "text": "100 proposals at test-time, indicating that the topranked RPN proposals are accurate. On the other extreme, using the top-ranked 6000 RPN proposals (without NMS) has a comparable mAP (55.2%), suggesting NMS does not harm the detection mAP and may reduce false alarms."
        },
        {
            "bounding_box": [
                {
                    "x": 144,
                    "y": 2103
                },
                {
                    "x": 1152,
                    "y": 2103
                },
                {
                    "x": 1152,
                    "y": 2550
                },
                {
                    "x": 144,
                    "y": 2550
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='109' style='font-size:20px'>Next, we separately investigate the roles of RPN's<br>cls and reg outputs by turning off either of them<br>at test-time. When the cls layer is removed at test-<br>time (thus no NMS /ranking is used), we randomly<br>sample N proposals from the unscored regions. The<br>mAP is nearly unchanged with N = 1000 (55.8%), but<br>degrades considerably to 44.6% when N = 100. This<br>shows that the cls scores account for the accuracy of<br>the highest ranked proposals.</p>",
            "id": 109,
            "page": 8,
            "text": "Next, we separately investigate the roles of RPN's cls and reg outputs by turning off either of them at test-time. When the cls layer is removed at testtime (thus no NMS /ranking is used), we randomly sample N proposals from the unscored regions. The mAP is nearly unchanged with N = 1000 (55.8%), but degrades considerably to 44.6% when N = 100. This shows that the cls scores account for the accuracy of the highest ranked proposals."
        },
        {
            "bounding_box": [
                {
                    "x": 142,
                    "y": 2566
                },
                {
                    "x": 1151,
                    "y": 2566
                },
                {
                    "x": 1151,
                    "y": 2910
                },
                {
                    "x": 142,
                    "y": 2910
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='110' style='font-size:22px'>On the other hand, when the reg layer is removed<br>at test-time (so the proposals become anchor boxes),<br>the mAP drops to 52.1%. This suggests that the high-<br>quality proposals are mainly due to the regressed box<br>bounds. The anchor boxes, though having multiple<br>scales and aspect ratios, are not sufficient for accurate<br>detection.</p>",
            "id": 110,
            "page": 8,
            "text": "On the other hand, when the reg layer is removed at test-time (so the proposals become anchor boxes), the mAP drops to 52.1%. This suggests that the highquality proposals are mainly due to the regressed box bounds. The anchor boxes, though having multiple scales and aspect ratios, are not sufficient for accurate detection."
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 2927
                },
                {
                    "x": 1152,
                    "y": 2927
                },
                {
                    "x": 1152,
                    "y": 3125
                },
                {
                    "x": 143,
                    "y": 3125
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='111' style='font-size:18px'>We also evaluate the effects of more powerful net-<br>works on the proposal quality of RPN alone. We use<br>VGG-16 to train the RPN, and still use the above<br>detector of SS+ZF. The mAP improves from 56.8%</p>",
            "id": 111,
            "page": 8,
            "text": "We also evaluate the effects of more powerful networks on the proposal quality of RPN alone. We use VGG-16 to train the RPN, and still use the above detector of SS+ZF. The mAP improves from 56.8%"
        },
        {
            "bounding_box": [
                {
                    "x": 1188,
                    "y": 1791
                },
                {
                    "x": 2197,
                    "y": 1791
                },
                {
                    "x": 2197,
                    "y": 2188
                },
                {
                    "x": 1188,
                    "y": 2188
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='112' style='font-size:22px'>(using RPN+ZF) to 59.2% (using RPN+VGG). This is a<br>promising result, because it suggests that the proposal<br>quality of RPN+ VGG is better than that of RPN+ZF.<br>Because proposals of RPN+ZF are competitive with<br>SS (both are 58.7% when consistently used for training<br>and testing), we may expect RPN+VGG to be better<br>than SS. The following experiments justify this hy-<br>pothesis.</p>",
            "id": 112,
            "page": 8,
            "text": "(using RPN+ZF) to 59.2% (using RPN+VGG). This is a promising result, because it suggests that the proposal quality of RPN+ VGG is better than that of RPN+ZF. Because proposals of RPN+ZF are competitive with SS (both are 58.7% when consistently used for training and testing), we may expect RPN+VGG to be better than SS. The following experiments justify this hypothesis."
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 2227
                },
                {
                    "x": 2201,
                    "y": 2227
                },
                {
                    "x": 2201,
                    "y": 3123
                },
                {
                    "x": 1190,
                    "y": 3123
                }
            ],
            "category": "paragraph",
            "html": "<p id='113' style='font-size:18px'>Performance of VGG-16. Table 3 shows the results<br>of VGG-16 for both proposal and detection. Using<br>RPN+VGG, the result is 68.5% for unshared features,<br>slightly higher than the SS baseline. As shown above,<br>this is because the proposals generated by RPN+VGG<br>are more accurate than SS. Unlike SS that is pre-<br>defined, the RPN is actively trained and benefits from<br>better networks. For the feature-shared variant, the<br>result is 69.9%-better than the strong SS baseline, yet<br>with nearly cost-free proposals. We further train the<br>RPN and detection network on the union set of PAS-<br>CAL VOC 2007 trainval and 2012 trainval. The mAP<br>is 73.2%. Figure 5 shows some results on the PASCAL<br>VOC 2007 test set. On the PASCAL VOC 2012 test set<br>(Table 4), our method has an mAP of 70.4% trained<br>on the union set of VOC 2007 trainval+test and VOC<br>2012 trainval. Table 6 and Table 7 show the detailed<br>numbers.</p>",
            "id": 113,
            "page": 8,
            "text": "Performance of VGG-16. Table 3 shows the results of VGG-16 for both proposal and detection. Using RPN+VGG, the result is 68.5% for unshared features, slightly higher than the SS baseline. As shown above, this is because the proposals generated by RPN+VGG are more accurate than SS. Unlike SS that is predefined, the RPN is actively trained and benefits from better networks. For the feature-shared variant, the result is 69.9%-better than the strong SS baseline, yet with nearly cost-free proposals. We further train the RPN and detection network on the union set of PASCAL VOC 2007 trainval and 2012 trainval. The mAP is 73.2%. Figure 5 shows some results on the PASCAL VOC 2007 test set. On the PASCAL VOC 2012 test set (Table 4), our method has an mAP of 70.4% trained on the union set of VOC 2007 trainval+test and VOC 2012 trainval. Table 6 and Table 7 show the detailed numbers."
        },
        {
            "bounding_box": [
                {
                    "x": 2175,
                    "y": 123
                },
                {
                    "x": 2194,
                    "y": 123
                },
                {
                    "x": 2194,
                    "y": 148
                },
                {
                    "x": 2175,
                    "y": 148
                }
            ],
            "category": "header",
            "html": "<header id='114' style='font-size:14px'>9</header>",
            "id": 114,
            "page": 9,
            "text": "9"
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 219
                },
                {
                    "x": 2195,
                    "y": 219
                },
                {
                    "x": 2195,
                    "y": 316
                },
                {
                    "x": 143,
                    "y": 316
                }
            ],
            "category": "caption",
            "html": "<caption id='115' style='font-size:18px'>Table 6: Results on PASCAL VOC 2007 test set with Fast R-CNN detectors and VGG-16. For RPN, the train-time<br>proposals for Fast R-CNN are 2000. RPN* denotes the unsharing feature version.</caption>",
            "id": 115,
            "page": 9,
            "text": "Table 6: Results on PASCAL VOC 2007 test set with Fast R-CNN detectors and VGG-16. For RPN, the train-time proposals for Fast R-CNN are 2000. RPN* denotes the unsharing feature version."
        },
        {
            "bounding_box": [
                {
                    "x": 150,
                    "y": 320
                },
                {
                    "x": 2188,
                    "y": 320
                },
                {
                    "x": 2188,
                    "y": 645
                },
                {
                    "x": 150,
                    "y": 645
                }
            ],
            "category": "table",
            "html": "<br><table id='116' style='font-size:14px'><tr><td>method</td><td># box</td><td>data</td><td>mAP</td><td>areo</td><td>bike</td><td>bird</td><td>boat</td><td>bottle</td><td>bus</td><td>car</td><td>cat</td><td>chair</td><td>COW</td><td>table</td><td>dog</td><td>horse</td><td>mbike</td><td>person</td><td>plant</td><td>sheep</td><td>sofa</td><td>train</td><td>tv</td></tr><tr><td>SS</td><td>2000</td><td>07</td><td>66.9</td><td>74.5</td><td>78.3</td><td>69.2</td><td>53.2</td><td>36.6</td><td>77.3</td><td>78.2</td><td>82.0</td><td>40.7</td><td>72.7</td><td>67.9</td><td>79.6</td><td>79.2</td><td>73.0</td><td>69.0</td><td>30.1</td><td>65.4</td><td>70.2</td><td>75.8</td><td>65.8</td></tr><tr><td>SS</td><td>2000</td><td>07+12</td><td>70.0</td><td>77.0</td><td>78.1</td><td>69.3</td><td>59.4</td><td>38.3</td><td>81.6</td><td>78.6</td><td>86.7</td><td>42.8</td><td>78.8</td><td>68.9</td><td>84.7</td><td>82.0</td><td>76.6</td><td>69.9</td><td>31.8</td><td>70.1</td><td>74.8</td><td>80.4</td><td>70.4</td></tr><tr><td>RPN*</td><td>300</td><td>07</td><td>68.5</td><td>74.1</td><td>77.2</td><td>67.7</td><td>53.9</td><td>51.0</td><td>75.1</td><td>79.2</td><td>78.9</td><td>50.7</td><td>78.0</td><td>61.1</td><td>79.1</td><td>81.9</td><td>72.2</td><td>75.9</td><td>37.2</td><td>71.4</td><td>62.5</td><td>77.4</td><td>66.4</td></tr><tr><td>RPN</td><td>300</td><td>07</td><td>69.9</td><td>70.0</td><td>80.6</td><td>70.1</td><td>57.3</td><td>49.9</td><td>78.2</td><td>80.4</td><td>82.0</td><td>52.2</td><td>75.3</td><td>67.2</td><td>80.3</td><td>79.8</td><td>75.0</td><td>76.3</td><td>39.1</td><td>68.3</td><td>67.3</td><td>81.1</td><td>67.6</td></tr><tr><td>RPN</td><td>300</td><td>07+12</td><td>73.2</td><td>76.5</td><td>79.0</td><td>70.9</td><td>65.5</td><td>52.1</td><td>83.1</td><td>84.7</td><td>86.4</td><td>52.0</td><td>81.9</td><td>65.7</td><td>84.8</td><td>84.6</td><td>77.5</td><td>76.7</td><td>38.8</td><td>73.6</td><td>73.9</td><td>83.0</td><td>72.6</td></tr><tr><td>RPN</td><td>300</td><td>COCO+07+12</td><td>78.8</td><td>84.3</td><td>82.0</td><td>77.7</td><td>68.9</td><td>65.7</td><td>88.1</td><td>88.4</td><td>88.9</td><td>63.6</td><td>86.3</td><td>70.8</td><td>85.9</td><td>87.6</td><td>80.1</td><td>82.3</td><td>53.6</td><td>80.4</td><td>75.8</td><td>86.6</td><td>78.9</td></tr></table>",
            "id": 116,
            "page": 9,
            "text": "method # box data mAP areo bike bird boat bottle bus car cat chair COW table dog horse mbike person plant sheep sofa train tv  SS 2000 07 66.9 74.5 78.3 69.2 53.2 36.6 77.3 78.2 82.0 40.7 72.7 67.9 79.6 79.2 73.0 69.0 30.1 65.4 70.2 75.8 65.8  SS 2000 07+12 70.0 77.0 78.1 69.3 59.4 38.3 81.6 78.6 86.7 42.8 78.8 68.9 84.7 82.0 76.6 69.9 31.8 70.1 74.8 80.4 70.4  RPN* 300 07 68.5 74.1 77.2 67.7 53.9 51.0 75.1 79.2 78.9 50.7 78.0 61.1 79.1 81.9 72.2 75.9 37.2 71.4 62.5 77.4 66.4  RPN 300 07 69.9 70.0 80.6 70.1 57.3 49.9 78.2 80.4 82.0 52.2 75.3 67.2 80.3 79.8 75.0 76.3 39.1 68.3 67.3 81.1 67.6  RPN 300 07+12 73.2 76.5 79.0 70.9 65.5 52.1 83.1 84.7 86.4 52.0 81.9 65.7 84.8 84.6 77.5 76.7 38.8 73.6 73.9 83.0 72.6  RPN 300 COCO+07+12 78.8 84.3 82.0 77.7 68.9 65.7 88.1 88.4 88.9 63.6 86.3 70.8 85.9 87.6 80.1 82.3 53.6 80.4 75.8 86.6"
        },
        {
            "bounding_box": [
                {
                    "x": 146,
                    "y": 712
                },
                {
                    "x": 2196,
                    "y": 712
                },
                {
                    "x": 2196,
                    "y": 809
                },
                {
                    "x": 146,
                    "y": 809
                }
            ],
            "category": "caption",
            "html": "<caption id='117' style='font-size:18px'>Table 7: Results on PASCAL VOC 2012 test set with Fast R-CNN detectors and VGG-16. For RPN, the train-time<br>proposals for Fast R-CNN are 2000.</caption>",
            "id": 117,
            "page": 9,
            "text": "Table 7: Results on PASCAL VOC 2012 test set with Fast R-CNN detectors and VGG-16. For RPN, the train-time proposals for Fast R-CNN are 2000."
        },
        {
            "bounding_box": [
                {
                    "x": 150,
                    "y": 815
                },
                {
                    "x": 2187,
                    "y": 815
                },
                {
                    "x": 2187,
                    "y": 1093
                },
                {
                    "x": 150,
                    "y": 1093
                }
            ],
            "category": "table",
            "html": "<br><table id='118' style='font-size:14px'><tr><td>method</td><td># box</td><td>data</td><td>mAP</td><td>areo</td><td>bike</td><td>bird</td><td>boat</td><td>bottle</td><td>bus</td><td>car</td><td>cat</td><td>chair</td><td>COW</td><td>table</td><td>dog</td><td>horse</td><td>mbike</td><td>person</td><td>plant</td><td>sheep</td><td>sofa</td><td>train</td><td>tv</td></tr><tr><td>SS</td><td>2000</td><td>12</td><td>65.7</td><td>80.3</td><td>74.7</td><td>66.9</td><td>46.9</td><td>37.7</td><td>73.9</td><td>68.6</td><td>87.7</td><td>41.7</td><td>71.1</td><td>51.1</td><td>86.0</td><td>77.8</td><td>79.8</td><td>69.8</td><td>32.1</td><td>65.5</td><td>63.8</td><td>76.4</td><td>61.7</td></tr><tr><td>SS</td><td>2000</td><td>07++12</td><td>68.4</td><td>82.3</td><td>78.4</td><td>70.8</td><td>52.3</td><td>38.7</td><td>77.8</td><td>71.6</td><td>89.3</td><td>44.2</td><td>73.0</td><td>55.0</td><td>87.5</td><td>80.5</td><td>80.8</td><td>72.0</td><td>35.1</td><td>68.3</td><td>65.7</td><td>80.4</td><td>64.2</td></tr><tr><td>RPN</td><td>300</td><td>12</td><td>67.0</td><td>82.3</td><td>76.4</td><td>71.0</td><td>48.4</td><td>45.2</td><td>72.1</td><td>72.3</td><td>87.3</td><td>42.2</td><td>73.7</td><td>50.0</td><td>86.8</td><td>78.7</td><td>78.4</td><td>77.4</td><td>34.5</td><td>70.1</td><td>57.1</td><td>77.1</td><td>58.9</td></tr><tr><td>RPN</td><td>300</td><td>07++12</td><td>70.4</td><td>84.9</td><td>79.8</td><td>74.3</td><td>53.9</td><td>49.8</td><td>77.5</td><td>75.9</td><td>88.5</td><td>45.6</td><td>77.1</td><td>55.3</td><td>86.9</td><td>81.7</td><td>80.9</td><td>79.6</td><td>40.1</td><td>72.6</td><td>60.9</td><td>81.2</td><td>61.5</td></tr><tr><td>RPN</td><td>300</td><td>COCO+07++12</td><td>75.9</td><td>87.4</td><td>83.6</td><td>76.8</td><td>62.9</td><td>59.6</td><td>81.9</td><td>82.0</td><td>91.3</td><td>54.9</td><td>82.6</td><td>59.0</td><td>89.0</td><td>85.5</td><td>84.7</td><td>84.1</td><td>52.2</td><td>78.9</td><td>65.5</td><td>85.4</td><td>70.2</td></tr></table>",
            "id": 118,
            "page": 9,
            "text": "method # box data mAP areo bike bird boat bottle bus car cat chair COW table dog horse mbike person plant sheep sofa train tv  SS 2000 12 65.7 80.3 74.7 66.9 46.9 37.7 73.9 68.6 87.7 41.7 71.1 51.1 86.0 77.8 79.8 69.8 32.1 65.5 63.8 76.4 61.7  SS 2000 07++12 68.4 82.3 78.4 70.8 52.3 38.7 77.8 71.6 89.3 44.2 73.0 55.0 87.5 80.5 80.8 72.0 35.1 68.3 65.7 80.4 64.2  RPN 300 12 67.0 82.3 76.4 71.0 48.4 45.2 72.1 72.3 87.3 42.2 73.7 50.0 86.8 78.7 78.4 77.4 34.5 70.1 57.1 77.1 58.9  RPN 300 07++12 70.4 84.9 79.8 74.3 53.9 49.8 77.5 75.9 88.5 45.6 77.1 55.3 86.9 81.7 80.9 79.6 40.1 72.6 60.9 81.2 61.5  RPN 300 COCO+07++12 75.9 87.4 83.6 76.8 62.9 59.6 81.9 82.0 91.3 54.9 82.6 59.0 89.0 85.5 84.7 84.1 52.2 78.9 65.5 85.4"
        },
        {
            "bounding_box": [
                {
                    "x": 144,
                    "y": 1195
                },
                {
                    "x": 1149,
                    "y": 1195
                },
                {
                    "x": 1149,
                    "y": 1490
                },
                {
                    "x": 144,
                    "y": 1490
                }
            ],
            "category": "paragraph",
            "html": "<p id='119' style='font-size:20px'>Table 8: Detection results of Faster R-CNN on PAS-<br>CAL VOC 2007 test set using different settings of<br>anchors. The network is VGG-16. The training data<br>is VOC 2007 trainval. The default setting of using 3<br>scales and 3 aspect ratios (69.9%) is the same as that<br>in Table 3.</p>",
            "id": 119,
            "page": 9,
            "text": "Table 8: Detection results of Faster R-CNN on PASCAL VOC 2007 test set using different settings of anchors. The network is VGG-16. The training data is VOC 2007 trainval. The default setting of using 3 scales and 3 aspect ratios (69.9%) is the same as that in Table 3."
        },
        {
            "bounding_box": [
                {
                    "x": 146,
                    "y": 1490
                },
                {
                    "x": 1152,
                    "y": 1490
                },
                {
                    "x": 1152,
                    "y": 1807
                },
                {
                    "x": 146,
                    "y": 1807
                }
            ],
            "category": "table",
            "html": "<br><table id='120' style='font-size:18px'><tr><td>settings</td><td>anchor scales</td><td>aspect ratios</td><td>mAP (%)</td></tr><tr><td>1 scale, 1 ratio</td><td>1282 2562</td><td>1:1 1:1</td><td>65.8 66.7</td></tr><tr><td>1 scale, 3 ratios</td><td>1282 2562</td><td>{2:1, 1:1, 1:2} {2:1, 1:1, 1:2}</td><td>68.8 67.9</td></tr><tr><td>3 scales, 1 ratio</td><td>{1282, 2562, 5122}</td><td>1:1</td><td>69.8</td></tr><tr><td>3 3</td><td></td><td></td><td>69.9</td></tr></table>",
            "id": 120,
            "page": 9,
            "text": "settings anchor scales aspect ratios mAP (%)  1 scale, 1 ratio 1282 2562 1:1 1:1 65.8 66.7  1 scale, 3 ratios 1282 2562 {2:1, 1:1, 1:2} {2:1, 1:1, 1:2} 68.8 67.9  3 scales, 1 ratio {1282, 2562, 5122} 1:1 69.8  3 3"
        },
        {
            "bounding_box": [
                {
                    "x": 151,
                    "y": 1790
                },
                {
                    "x": 1097,
                    "y": 1790
                },
                {
                    "x": 1097,
                    "y": 1826
                },
                {
                    "x": 151,
                    "y": 1826
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='121' style='font-size:22px'>scales, ratios {1282, 2562, 5122} {2:1, 1:1, 1:2}</p>",
            "id": 121,
            "page": 9,
            "text": "scales, ratios {1282, 2562, 5122} {2:1, 1:1, 1:2}"
        },
        {
            "bounding_box": [
                {
                    "x": 145,
                    "y": 1921
                },
                {
                    "x": 1150,
                    "y": 1921
                },
                {
                    "x": 1150,
                    "y": 2165
                },
                {
                    "x": 145,
                    "y": 2165
                }
            ],
            "category": "paragraph",
            "html": "<p id='122' style='font-size:18px'>Table 9: Detection results of Faster R-CNN on PAS-<br>CAL VOC 2007 test set using different values of 入<br>in Equation (1). The network is VGG-16. The training<br>data is VOC 2007 trainval. The default setting of using<br>入 = 10 (69.9%) is the same as that in Table 3.</p>",
            "id": 122,
            "page": 9,
            "text": "Table 9: Detection results of Faster R-CNN on PASCAL VOC 2007 test set using different values of 入 in Equation (1). The network is VGG-16. The training data is VOC 2007 trainval. The default setting of using 入 = 10 (69.9%) is the same as that in Table 3."
        },
        {
            "bounding_box": [
                {
                    "x": 249,
                    "y": 2171
                },
                {
                    "x": 1060,
                    "y": 2171
                },
                {
                    "x": 1060,
                    "y": 2263
                },
                {
                    "x": 249,
                    "y": 2263
                }
            ],
            "category": "table",
            "html": "<br><table id='123' style='font-size:16px'><tr><td>入</td><td>0.1</td><td>1</td><td>10</td><td>100</td></tr><tr><td>mAP (%)</td><td>67.2</td><td>68.9</td><td>69.9</td><td>69.1</td></tr></table>",
            "id": 123,
            "page": 9,
            "text": "入 0.1 1 10 100  mAP (%) 67.2 68.9 69.9"
        },
        {
            "bounding_box": [
                {
                    "x": 145,
                    "y": 2399
                },
                {
                    "x": 1152,
                    "y": 2399
                },
                {
                    "x": 1152,
                    "y": 2998
                },
                {
                    "x": 145,
                    "y": 2998
                }
            ],
            "category": "paragraph",
            "html": "<p id='124' style='font-size:22px'>In Table 5 we summarize the running time of the<br>entire object detection system. SS takes 1-2 seconds<br>depending on content (on average about 1.5s), and<br>Fast R-CNN with VGG-16 takes 320ms on 2000 SS<br>proposals (or 223ms if using SVD on fully-connected<br>layers [2]). Our system with VGG-16 takes in total<br>198ms for both proposal and detection. With the con-<br>volutional features shared, the RPN alone only takes<br>10ms computing the additional layers. Our region-<br>wise computation is also lower, thanks to fewer pro-<br>posals (300 per image). Our system has a frame-rate<br>of 17 fps with the ZF net.</p>",
            "id": 124,
            "page": 9,
            "text": "In Table 5 we summarize the running time of the entire object detection system. SS takes 1-2 seconds depending on content (on average about 1.5s), and Fast R-CNN with VGG-16 takes 320ms on 2000 SS proposals (or 223ms if using SVD on fully-connected layers ). Our system with VGG-16 takes in total 198ms for both proposal and detection. With the convolutional features shared, the RPN alone only takes 10ms computing the additional layers. Our regionwise computation is also lower, thanks to fewer proposals (300 per image). Our system has a frame-rate of 17 fps with the ZF net."
        },
        {
            "bounding_box": [
                {
                    "x": 144,
                    "y": 3028
                },
                {
                    "x": 1148,
                    "y": 3028
                },
                {
                    "x": 1148,
                    "y": 3122
                },
                {
                    "x": 144,
                    "y": 3122
                }
            ],
            "category": "paragraph",
            "html": "<p id='125' style='font-size:20px'>Sensitivities to Hyper-parameters. In Table 8 we<br>investigate the settings of anchors. By default we use</p>",
            "id": 125,
            "page": 9,
            "text": "Sensitivities to Hyper-parameters. In Table 8 we investigate the settings of anchors. By default we use"
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 1209
                },
                {
                    "x": 2197,
                    "y": 1209
                },
                {
                    "x": 2197,
                    "y": 1806
                },
                {
                    "x": 1190,
                    "y": 1806
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='126' style='font-size:22px'>3 scales and 3 aspect ratios (69.9% mAP in Table 8).<br>If using just one anchor at each position, the mAP<br>drops by a considerable margin of 3-4%. The mAP<br>is higher if using 3 scales (with 1 aspect ratio) or 3<br>aspect ratios (with 1 scale), demonstrating that using<br>anchors of multiple sizes as the regression references<br>is an effective solution. Using just 3 scales with 1<br>aspect ratio (69.8%) is as good as using 3 scales with<br>3 aspect ratios on this dataset, suggesting that scales<br>and aspect ratios are not disentangled dimensions for<br>the detection accuracy. But we still adopt these two<br>dimensions in our designs to keep our system flexible.</p>",
            "id": 126,
            "page": 9,
            "text": "3 scales and 3 aspect ratios (69.9% mAP in Table 8). If using just one anchor at each position, the mAP drops by a considerable margin of 3-4%. The mAP is higher if using 3 scales (with 1 aspect ratio) or 3 aspect ratios (with 1 scale), demonstrating that using anchors of multiple sizes as the regression references is an effective solution. Using just 3 scales with 1 aspect ratio (69.8%) is as good as using 3 scales with 3 aspect ratios on this dataset, suggesting that scales and aspect ratios are not disentangled dimensions for the detection accuracy. But we still adopt these two dimensions in our designs to keep our system flexible."
        },
        {
            "bounding_box": [
                {
                    "x": 1189,
                    "y": 1810
                },
                {
                    "x": 2194,
                    "y": 1810
                },
                {
                    "x": 2194,
                    "y": 2205
                },
                {
                    "x": 1189,
                    "y": 2205
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='127' style='font-size:20px'>In Table 9 we compare different values of 入 in Equa-<br>tion (1). By default we use 入 = 10 which makes the<br>two terms in Equation (1) roughly equally weighted<br>after normalization. Table 9 shows that our result is<br>impacted just marginally (by ~ 1%) when 入 is within<br>a scale of about two orders of magnitude (1 to 100).<br>This demonstrates that the result is insensitive to 入 in<br>a wide range.</p>",
            "id": 127,
            "page": 9,
            "text": "In Table 9 we compare different values of 入 in Equation (1). By default we use 入 = 10 which makes the two terms in Equation (1) roughly equally weighted after normalization. Table 9 shows that our result is impacted just marginally (by ~ 1%) when 入 is within a scale of about two orders of magnitude (1 to 100). This demonstrates that the result is insensitive to 入 in a wide range."
        },
        {
            "bounding_box": [
                {
                    "x": 1188,
                    "y": 2229
                },
                {
                    "x": 2196,
                    "y": 2229
                },
                {
                    "x": 2196,
                    "y": 2571
                },
                {
                    "x": 1188,
                    "y": 2571
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='128' style='font-size:20px'>Analysis of Recall-to-IoU. Next we compute the<br>recall of proposals at different IoU ratios with ground-<br>truth boxes. It is noteworthy that the Recall-to-IoU<br>metric is just loosely [19], [20], [21] related to the<br>ultimate detection accuracy. It is more appropriate to<br>use this metric to diagnose the proposal method than<br>to evaluate it.</p>",
            "id": 128,
            "page": 9,
            "text": "Analysis of Recall-to-IoU. Next we compute the recall of proposals at different IoU ratios with groundtruth boxes. It is noteworthy that the Recall-to-IoU metric is just loosely , ,  related to the ultimate detection accuracy. It is more appropriate to use this metric to diagnose the proposal method than to evaluate it."
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 2577
                },
                {
                    "x": 2198,
                    "y": 2577
                },
                {
                    "x": 2198,
                    "y": 3126
                },
                {
                    "x": 1190,
                    "y": 3126
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='129' style='font-size:20px'>In Figure 4, we show the results of using 300, 1000,<br>and 2000 proposals. We compare with SS and EB, and<br>the N proposals are the top-N ranked ones based on<br>the confidence generated by these methods. The plots<br>show that the RPN method behaves gracefully when<br>the number of proposals drops from 2000 to 300. This<br>explains why the RPN has a good ultimate detection<br>mAP when using as few as 300 proposals. As we<br>analyzed before, this property is mainly attributed to<br>the cls term of the RPN. The recall of SS and EB drops<br>more quickly than RPN when the proposals are fewer.</p>",
            "id": 129,
            "page": 9,
            "text": "In Figure 4, we show the results of using 300, 1000, and 2000 proposals. We compare with SS and EB, and the N proposals are the top-N ranked ones based on the confidence generated by these methods. The plots show that the RPN method behaves gracefully when the number of proposals drops from 2000 to 300. This explains why the RPN has a good ultimate detection mAP when using as few as 300 proposals. As we analyzed before, this property is mainly attributed to the cls term of the RPN. The recall of SS and EB drops more quickly than RPN when the proposals are fewer."
        },
        {
            "bounding_box": [
                {
                    "x": 2160,
                    "y": 121
                },
                {
                    "x": 2197,
                    "y": 121
                },
                {
                    "x": 2197,
                    "y": 151
                },
                {
                    "x": 2160,
                    "y": 151
                }
            ],
            "category": "header",
            "html": "<header id='130' style='font-size:14px'>10</header>",
            "id": 130,
            "page": 10,
            "text": "10"
        },
        {
            "bounding_box": [
                {
                    "x": 446,
                    "y": 215
                },
                {
                    "x": 1894,
                    "y": 215
                },
                {
                    "x": 1894,
                    "y": 624
                },
                {
                    "x": 446,
                    "y": 624
                }
            ],
            "category": "figure",
            "html": "<figure><img id='131' style='font-size:14px' alt=\"300 proposals 1000 proposals 2000 proposals\n1 1 1\n0.8 0.8 0.8\nRecall\n0.6 0.6 0.6\n····+··· SS ········· SS ····· SS\n0.4 0.4 0.4\nEB EB EB\n0.2 RPN ZF 0.2 RPN ZF 0.2 RPN ZF\nRPN VGG RPN VGG RPN VGG\n0.5 0.6 0.7 0.8 0.9 1 0.5 0.6 0.7 0.8 0.9 1 0.5 0.6 0.7 0.8 0.9 1\nIoU IoU IoU\" data-coord=\"top-left:(446,215); bottom-right:(1894,624)\" /></figure>",
            "id": 131,
            "page": 10,
            "text": "300 proposals 1000 proposals 2000 proposals 1 1 1 0.8 0.8 0.8 Recall 0.6 0.6 0.6 ····+··· SS ········· SS ····· SS 0.4 0.4 0.4 EB EB EB 0.2 RPN ZF 0.2 RPN ZF 0.2 RPN ZF RPN VGG RPN VGG RPN VGG 0.5 0.6 0.7 0.8 0.9 1 0.5 0.6 0.7 0.8 0.9 1 0.5 0.6 0.7 0.8 0.9 1 IoU IoU IoU"
        },
        {
            "bounding_box": [
                {
                    "x": 489,
                    "y": 651
                },
                {
                    "x": 1852,
                    "y": 651
                },
                {
                    "x": 1852,
                    "y": 698
                },
                {
                    "x": 489,
                    "y": 698
                }
            ],
            "category": "caption",
            "html": "<caption id='132' style='font-size:18px'>Figure 4: Recall vs. IoU overlap ratio on the PASCAL VOC 2007 test set.</caption>",
            "id": 132,
            "page": 10,
            "text": "Figure 4: Recall vs. IoU overlap ratio on the PASCAL VOC 2007 test set."
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 748
                },
                {
                    "x": 2194,
                    "y": 748
                },
                {
                    "x": 2194,
                    "y": 849
                },
                {
                    "x": 143,
                    "y": 849
                }
            ],
            "category": "caption",
            "html": "<caption id='133' style='font-size:16px'>Table 10: One-Stage Detection vs. Two-Stage Proposal + Detection. Detection results are on the PASCAL<br>VOC 2007 test set using the ZF model and Fast R-CNN. RPN uses unshared features.</caption>",
            "id": 133,
            "page": 10,
            "text": "Table 10: One-Stage Detection vs. Two-Stage Proposal + Detection. Detection results are on the PASCAL VOC 2007 test set using the ZF model and Fast R-CNN. RPN uses unshared features."
        },
        {
            "bounding_box": [
                {
                    "x": 337,
                    "y": 845
                },
                {
                    "x": 1987,
                    "y": 845
                },
                {
                    "x": 1987,
                    "y": 1055
                },
                {
                    "x": 337,
                    "y": 1055
                }
            ],
            "category": "table",
            "html": "<br><table id='134' style='font-size:16px'><tr><td></td><td colspan=\"2\">proposals</td><td>detector</td><td>mAP (%)</td></tr><tr><td>Two-Stage</td><td>RPN + ZF, unshared</td><td>300</td><td>Fast R-CNN + ZF, 1 scale</td><td>58.7</td></tr><tr><td>One-Stage</td><td>dense, 3 scales, 3 aspect ratios</td><td>20000</td><td>Fast R-CNN + ZF, 1 scale</td><td>53.8</td></tr><tr><td>One-Stage</td><td>dense, 3 scales, 3 aspect ratios</td><td>20000</td><td>Fast R-CNN + ZF, 5 scales</td><td>53.9</td></tr></table>",
            "id": 134,
            "page": 10,
            "text": "proposals detector mAP (%)  Two-Stage RPN + ZF, unshared 300 Fast R-CNN + ZF, 1 scale 58.7  One-Stage dense, 3 scales, 3 aspect ratios 20000 Fast R-CNN + ZF, 1 scale 53.8  One-Stage dense, 3 scales, 3 aspect ratios 20000 Fast R-CNN + ZF, 5 scales"
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 1166
                },
                {
                    "x": 1153,
                    "y": 1166
                },
                {
                    "x": 1153,
                    "y": 2217
                },
                {
                    "x": 143,
                    "y": 2217
                }
            ],
            "category": "paragraph",
            "html": "<p id='135' style='font-size:20px'>One-Stage Detection vs. Two-Stage Proposal + De-<br>tection. The OverFeat paper [9] proposes a detection<br>method that uses regressors and classifiers on sliding<br>windows over convolutional feature maps. OverFeat<br>is a one-stage, class-specific detection pipeline, and ours<br>is a two-stage cascade consisting of class-agnostic pro-<br>posals and class-specific detections. In OverFeat, the<br>region-wise features come from a sliding window of<br>one aspect ratio over a scale pyramid. These features<br>are used to simultaneously determine the location and<br>category of objects. In RPN, the features are from<br>square (3x3) sliding windows and predict proposals<br>relative to anchors with different scales and aspect<br>ratios. Though both methods use sliding windows, the<br>region proposal task is only the first stage of Faster R-<br>CNN-the downstream Fast R-CNN detector attends<br>to the proposals to refine them. In the second stage of<br>our cascade, the region-wise features are adaptively<br>pooled [1], [2] from proposal boxes that more faith-<br>fully cover the features of the regions. We believe<br>these features lead to more accurate detections.</p>",
            "id": 135,
            "page": 10,
            "text": "One-Stage Detection vs. Two-Stage Proposal + Detection. The OverFeat paper  proposes a detection method that uses regressors and classifiers on sliding windows over convolutional feature maps. OverFeat is a one-stage, class-specific detection pipeline, and ours is a two-stage cascade consisting of class-agnostic proposals and class-specific detections. In OverFeat, the region-wise features come from a sliding window of one aspect ratio over a scale pyramid. These features are used to simultaneously determine the location and category of objects. In RPN, the features are from square (3x3) sliding windows and predict proposals relative to anchors with different scales and aspect ratios. Though both methods use sliding windows, the region proposal task is only the first stage of Faster RCNN-the downstream Fast R-CNN detector attends to the proposals to refine them. In the second stage of our cascade, the region-wise features are adaptively pooled ,  from proposal boxes that more faithfully cover the features of the regions. We believe these features lead to more accurate detections."
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 2224
                },
                {
                    "x": 1152,
                    "y": 2224
                },
                {
                    "x": 1152,
                    "y": 2770
                },
                {
                    "x": 143,
                    "y": 2770
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='136' style='font-size:20px'>To compare the one-stage and two-stage systems,<br>we emulate the OverFeat system (and thus also circum-<br>vent other differences of implementation details) by<br>one-stage Fast R-CNN. In this system, the \"proposals\"<br>are dense sliding windows of 3 scales (128, 256, 512)<br>and 3 aspect ratios (1:1, 1:2, 2:1). Fast R-CNN is<br>trained to predict class-specific scores and regress box<br>locations from these sliding windows. Because the<br>OverFeat system adopts an image pyramid, we also<br>evaluate using convolutional features extracted from<br>5 scales. We use those 5 scales as in [1], [2].</p>",
            "id": 136,
            "page": 10,
            "text": "To compare the one-stage and two-stage systems, we emulate the OverFeat system (and thus also circumvent other differences of implementation details) by one-stage Fast R-CNN. In this system, the \"proposals\" are dense sliding windows of 3 scales (128, 256, 512) and 3 aspect ratios (1:1, 1:2, 2:1). Fast R-CNN is trained to predict class-specific scores and regress box locations from these sliding windows. Because the OverFeat system adopts an image pyramid, we also evaluate using convolutional features extracted from 5 scales. We use those 5 scales as in , ."
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 2778
                },
                {
                    "x": 1152,
                    "y": 2778
                },
                {
                    "x": 1152,
                    "y": 3128
                },
                {
                    "x": 143,
                    "y": 3128
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='137' style='font-size:20px'>Table 10 compares the two-stage system and two<br>variants of the one-stage system. Using the ZF model,<br>the one-stage system has an mAP of 53.9%. This is<br>lower than the two-stage system (58.7%) by 4.8%.<br>This experiment justifies the effectiveness of cascaded<br>region proposals and object detection. Similar obser-<br>vations are reported in [2], [39], where replacing SS</p>",
            "id": 137,
            "page": 10,
            "text": "Table 10 compares the two-stage system and two variants of the one-stage system. Using the ZF model, the one-stage system has an mAP of 53.9%. This is lower than the two-stage system (58.7%) by 4.8%. This experiment justifies the effectiveness of cascaded region proposals and object detection. Similar observations are reported in , , where replacing SS"
        },
        {
            "bounding_box": [
                {
                    "x": 1188,
                    "y": 1172
                },
                {
                    "x": 2197,
                    "y": 1172
                },
                {
                    "x": 2197,
                    "y": 1371
                },
                {
                    "x": 1188,
                    "y": 1371
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='138' style='font-size:20px'>region proposals with sliding windows leads to ~6%<br>degradation in both papers. We also note that the one-<br>stage system is slower as it has considerably more<br>proposals to process.</p>",
            "id": 138,
            "page": 10,
            "text": "region proposals with sliding windows leads to ~6% degradation in both papers. We also note that the onestage system is slower as it has considerably more proposals to process."
        },
        {
            "bounding_box": [
                {
                    "x": 1186,
                    "y": 1455
                },
                {
                    "x": 1821,
                    "y": 1455
                },
                {
                    "x": 1821,
                    "y": 1503
                },
                {
                    "x": 1186,
                    "y": 1503
                }
            ],
            "category": "paragraph",
            "html": "<p id='139' style='font-size:22px'>4.2 Experiments on MS COCO</p>",
            "id": 139,
            "page": 10,
            "text": "4.2 Experiments on MS COCO"
        },
        {
            "bounding_box": [
                {
                    "x": 1188,
                    "y": 1528
                },
                {
                    "x": 2199,
                    "y": 1528
                },
                {
                    "x": 2199,
                    "y": 1924
                },
                {
                    "x": 1188,
                    "y": 1924
                }
            ],
            "category": "paragraph",
            "html": "<p id='140' style='font-size:20px'>We present more results on the Microsoft COCO<br>object detection dataset [12]. This dataset involves 80<br>object categories. We experiment with the 80k images<br>on the training set, 40k images on the validation set,<br>and 20k images on the test-dev set. We evaluate the<br>mAP averaged for IoU E [0.5 : 0.05 : 0.95] (COCO's<br>standard metric, simply denoted as mAP@[.5, .95])<br>and mAP@0.5 (PASCAL VOC's metric).</p>",
            "id": 140,
            "page": 10,
            "text": "We present more results on the Microsoft COCO object detection dataset . This dataset involves 80 object categories. We experiment with the 80k images on the training set, 40k images on the validation set, and 20k images on the test-dev set. We evaluate the mAP averaged for IoU E [0.5 : 0.05 : 0.95] (COCO's standard metric, simply denoted as mAP@[.5, .95]) and mAP@0.5 (PASCAL VOC's metric)."
        },
        {
            "bounding_box": [
                {
                    "x": 1189,
                    "y": 1929
                },
                {
                    "x": 2200,
                    "y": 1929
                },
                {
                    "x": 2200,
                    "y": 3129
                },
                {
                    "x": 1189,
                    "y": 3129
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='141' style='font-size:20px'>There are a few minor changes of our system made<br>for this dataset. We train our models on an 8-GPU<br>implementation, and the effective mini-batch size be-<br>comes 8 for RPN (1 per GPU) and 16 for Fast R-CNN<br>(2 per GPU). The RPN step and Fast R-CNN step are<br>both trained for 240k iterations with a learning rate<br>of 0.003 and then for 80k iterations with 0.0003. We<br>modify the learning rates (starting with 0.003 instead<br>of 0.001) because the mini-batch size is changed. For<br>the anchors, we use 3 aspect ratios and 4 scales<br>(adding 642), mainly motivated by handling small<br>objects on this dataset. In addition, in our Fast R-CNN<br>step, the negative samples are defined as those with<br>a maximum IoU with ground truth in the interval of<br>[0, 0.5), instead of [0.1, 0.5) used in [1], [2]. We note<br>that in the SPPnet system [1], the negative samples<br>in [0.1, 0.5) are used for network fine-tuning, but the<br>negative samples in [0, 0.5) are still visited in the SVM<br>step with hard-negative mining. But the Fast R-CNN<br>system [2] abandons the SVM step, SO the negative<br>samples in [0, 0.1) are never visited. Including these<br>[0, 0.1) samples improves mAP@0.5 on the COCO<br>dataset for both Fast R-CNN and Faster R-CNN sys-<br>tems (but the impact is negligible on PASCAL VOC).</p>",
            "id": 141,
            "page": 10,
            "text": "There are a few minor changes of our system made for this dataset. We train our models on an 8-GPU implementation, and the effective mini-batch size becomes 8 for RPN (1 per GPU) and 16 for Fast R-CNN (2 per GPU). The RPN step and Fast R-CNN step are both trained for 240k iterations with a learning rate of 0.003 and then for 80k iterations with 0.0003. We modify the learning rates (starting with 0.003 instead of 0.001) because the mini-batch size is changed. For the anchors, we use 3 aspect ratios and 4 scales (adding 642), mainly motivated by handling small objects on this dataset. In addition, in our Fast R-CNN step, the negative samples are defined as those with a maximum IoU with ground truth in the interval of [0, 0.5), instead of [0.1, 0.5) used in , . We note that in the SPPnet system , the negative samples in [0.1, 0.5) are used for network fine-tuning, but the negative samples in [0, 0.5) are still visited in the SVM step with hard-negative mining. But the Fast R-CNN system  abandons the SVM step, SO the negative samples in [0, 0.1) are never visited. Including these [0, 0.1) samples improves mAP@0.5 on the COCO dataset for both Fast R-CNN and Faster R-CNN systems (but the impact is negligible on PASCAL VOC)."
        },
        {
            "bounding_box": [
                {
                    "x": 2161,
                    "y": 121
                },
                {
                    "x": 2194,
                    "y": 121
                },
                {
                    "x": 2194,
                    "y": 151
                },
                {
                    "x": 2161,
                    "y": 151
                }
            ],
            "category": "header",
            "html": "<header id='142' style='font-size:14px'>11</header>",
            "id": 142,
            "page": 11,
            "text": "11"
        },
        {
            "bounding_box": [
                {
                    "x": 345,
                    "y": 220
                },
                {
                    "x": 1987,
                    "y": 220
                },
                {
                    "x": 1987,
                    "y": 264
                },
                {
                    "x": 345,
                    "y": 264
                }
            ],
            "category": "caption",
            "html": "<caption id='143' style='font-size:16px'>Table 11: Object detection results (%) on the MS COCO dataset. The model is VGG-16.</caption>",
            "id": 143,
            "page": 11,
            "text": "Table 11: Object detection results (%) on the MS COCO dataset. The model is VGG-16."
        },
        {
            "bounding_box": [
                {
                    "x": 173,
                    "y": 272
                },
                {
                    "x": 2161,
                    "y": 272
                },
                {
                    "x": 2161,
                    "y": 567
                },
                {
                    "x": 173,
                    "y": 567
                }
            ],
            "category": "table",
            "html": "<br><table id='144' style='font-size:16px'><tr><td></td><td></td><td></td><td colspan=\"2\">COCO val</td><td colspan=\"2\">COCO test-dev</td></tr><tr><td>method</td><td>proposals</td><td>training data</td><td>mAP@.5</td><td>mAP@[.5, .95]</td><td>mAP@.5</td><td>mAP@[.5, .95]</td></tr><tr><td>Fast R-CNN [2]</td><td>SS, 2000</td><td>COCO train</td><td>-</td><td>-</td><td>35.9</td><td>19.7</td></tr><tr><td>Fast R-CNN [impl. in this paper]</td><td>SS, 2000</td><td>COCO train</td><td>38.6</td><td>18.9</td><td>39.3</td><td>19.3</td></tr><tr><td>Faster R-CNN</td><td>RPN, 300</td><td>COCO train</td><td>41.5</td><td>21.2</td><td>42.1</td><td>21.5</td></tr><tr><td>Faster R-CNN</td><td>RPN, 300</td><td>COCO trainval</td><td>-</td><td>-</td><td>42.7</td><td>21.9</td></tr></table>",
            "id": 144,
            "page": 11,
            "text": "COCO val COCO test-dev  method proposals training data mAP@.5 mAP@[.5, .95] mAP@.5 mAP@[.5, .95]  Fast R-CNN  SS, 2000 COCO train - - 35.9 19.7  Fast R-CNN [impl. in this paper] SS, 2000 COCO train 38.6 18.9 39.3 19.3  Faster R-CNN RPN, 300 COCO train 41.5 21.2 42.1 21.5  Faster R-CNN RPN, 300 COCO trainval - - 42.7"
        },
        {
            "bounding_box": [
                {
                    "x": 144,
                    "y": 682
                },
                {
                    "x": 1152,
                    "y": 682
                },
                {
                    "x": 1152,
                    "y": 928
                },
                {
                    "x": 144,
                    "y": 928
                }
            ],
            "category": "paragraph",
            "html": "<p id='145' style='font-size:16px'>The rest of the implementation details are the same<br>as on PASCAL VOC. In particular, we keep using<br>300 proposals and single-scale (s = 600) testing. The<br>testing time is still about 200ms per image on the<br>COCO dataset.</p>",
            "id": 145,
            "page": 11,
            "text": "The rest of the implementation details are the same as on PASCAL VOC. In particular, we keep using 300 proposals and single-scale (s = 600) testing. The testing time is still about 200ms per image on the COCO dataset."
        },
        {
            "bounding_box": [
                {
                    "x": 144,
                    "y": 958
                },
                {
                    "x": 1153,
                    "y": 958
                },
                {
                    "x": 1153,
                    "y": 1356
                },
                {
                    "x": 144,
                    "y": 1356
                }
            ],
            "category": "paragraph",
            "html": "<p id='146' style='font-size:18px'>In Table 11 we first report the results of the Fast<br>R-CNN system [2] using the implementation in this<br>paper. Our Fast R-CNN baseline has 39.3% mAP@0.5<br>on the test-dev set, higher than that reported in [2].<br>We conjecture that the reason for this gap is mainly<br>due to the definition of the negative samples and also<br>the changes of the mini-batch sizes. We also note that<br>the mAP@[.5, .95] is just comparable.</p>",
            "id": 146,
            "page": 11,
            "text": "In Table 11 we first report the results of the Fast R-CNN system  using the implementation in this paper. Our Fast R-CNN baseline has 39.3% mAP@0.5 on the test-dev set, higher than that reported in . We conjecture that the reason for this gap is mainly due to the definition of the negative samples and also the changes of the mini-batch sizes. We also note that the mAP@[.5, .95] is just comparable."
        },
        {
            "bounding_box": [
                {
                    "x": 144,
                    "y": 1382
                },
                {
                    "x": 1154,
                    "y": 1382
                },
                {
                    "x": 1154,
                    "y": 1980
                },
                {
                    "x": 144,
                    "y": 1980
                }
            ],
            "category": "paragraph",
            "html": "<p id='147' style='font-size:18px'>Next we evaluate our Faster R-CNN system. Using<br>the COCO training set to train, Faster R-CNN has<br>42.1% mAP@0.5 and 21.5% mAP@[.5, .95] on the<br>COCO test-dev set. This is 2.8% higher for mAP@0.5<br>and 2.2% higher for mAP@[.5, .95] than the Fast R-<br>CNN counterpart under the same protocol (Table 11).<br>This indicates that RPN performs excellent for im-<br>proving the localization accuracy at higher IoU thresh-<br>olds. Using the COCO trainval set to train, Faster R-<br>CNN has 42.7% mAP@0.5 and 21.9% mAP@[.5, .95] on<br>the COCO test-dev set. Figure 6 shows some results<br>on the MS COCO test-dev set.</p>",
            "id": 147,
            "page": 11,
            "text": "Next we evaluate our Faster R-CNN system. Using the COCO training set to train, Faster R-CNN has 42.1% mAP@0.5 and 21.5% mAP@[.5, .95] on the COCO test-dev set. This is 2.8% higher for mAP@0.5 and 2.2% higher for mAP@[.5, .95] than the Fast RCNN counterpart under the same protocol (Table 11). This indicates that RPN performs excellent for improving the localization accuracy at higher IoU thresholds. Using the COCO trainval set to train, Faster RCNN has 42.7% mAP@0.5 and 21.9% mAP@[.5, .95] on the COCO test-dev set. Figure 6 shows some results on the MS COCO test-dev set."
        },
        {
            "bounding_box": [
                {
                    "x": 143,
                    "y": 2026
                },
                {
                    "x": 1153,
                    "y": 2026
                },
                {
                    "x": 1153,
                    "y": 3130
                },
                {
                    "x": 143,
                    "y": 3130
                }
            ],
            "category": "paragraph",
            "html": "<p id='148' style='font-size:18px'>Faster R-CNN in ILSVRC & COCO 2015 compe-<br>titions We have demonstrated that Faster R-CNN<br>benefits more from better features, thanks to the fact<br>that the RPN completely learns to propose regions by<br>neural networks. This observation is still valid even<br>when one increases the depth substantially to over<br>100 layers [18]. Only by replacing VGG-16 with a 101-<br>layer residual net (ResNet-101) [18], the Faster R-CNN<br>system increases the mAP from 41.5% /21.2% (VGG-<br>16) to 48.4%/27.2% (ResNet-101) on the COCO val<br>set. With other improvements orthogonal to Faster R-<br>CNN, He et al. [18] obtained a single-model result of<br>55.7% /34.9% and an ensemble result of 59.0% /37.4%<br>on the COCO test-dev set, which won the 1st place<br>in the COCO 2015 object detection competition. The<br>same system [18] also won the 1st place in the ILSVRC<br>2015 object detection competition, surpassing the sec-<br>ond place by absolute 8.5% RPN is also a building<br>block of the 1st-place winning entries in ILSVRC 2015<br>localization and COCO 2015 segmentation competi-<br>tions, for which the details are available in [18] and<br>[15] respectively.</p>",
            "id": 148,
            "page": 11,
            "text": "Faster R-CNN in ILSVRC & COCO 2015 competitions We have demonstrated that Faster R-CNN benefits more from better features, thanks to the fact that the RPN completely learns to propose regions by neural networks. This observation is still valid even when one increases the depth substantially to over 100 layers . Only by replacing VGG-16 with a 101layer residual net (ResNet-101) , the Faster R-CNN system increases the mAP from 41.5% /21.2% (VGG16) to 48.4%/27.2% (ResNet-101) on the COCO val set. With other improvements orthogonal to Faster RCNN, He   obtained a single-model result of 55.7% /34.9% and an ensemble result of 59.0% /37.4% on the COCO test-dev set, which won the 1st place in the COCO 2015 object detection competition. The same system  also won the 1st place in the ILSVRC 2015 object detection competition, surpassing the second place by absolute 8.5% RPN is also a building block of the 1st-place winning entries in ILSVRC 2015 localization and COCO 2015 segmentation competitions, for which the details are available in  and  respectively."
        },
        {
            "bounding_box": [
                {
                    "x": 1189,
                    "y": 668
                },
                {
                    "x": 2196,
                    "y": 668
                },
                {
                    "x": 2196,
                    "y": 911
                },
                {
                    "x": 1189,
                    "y": 911
                }
            ],
            "category": "caption",
            "html": "<br><caption id='149' style='font-size:16px'>Table 12: Detection mAP (%) of Faster R-CNN on<br>PASCAL VOC 2007 test set and 2012 test set us-<br>ing different training data. The model is VGG-16.<br>\"COCO\" denotes that the COCO trainval set is used<br>for training. See also Table 6 and Table 7.</caption>",
            "id": 149,
            "page": 11,
            "text": "Table 12: Detection mAP (%) of Faster R-CNN on PASCAL VOC 2007 test set and 2012 test set using different training data. The model is VGG-16. \"COCO\" denotes that the COCO trainval set is used for training. See also Table 6 and Table 7."
        },
        {
            "bounding_box": [
                {
                    "x": 1264,
                    "y": 911
                },
                {
                    "x": 2109,
                    "y": 911
                },
                {
                    "x": 2109,
                    "y": 1260
                },
                {
                    "x": 1264,
                    "y": 1260
                }
            ],
            "category": "table",
            "html": "<br><table id='150' style='font-size:14px'><tr><td>training data</td><td>2007 test</td><td>2012 test</td></tr><tr><td>VOC07</td><td>69.9</td><td>67.0</td></tr><tr><td>VOC07+12</td><td>73.2</td><td>-</td></tr><tr><td>VOC07++12</td><td>-</td><td>70.4</td></tr><tr><td>COCO (no VOC)</td><td>76.1</td><td>73.0</td></tr><tr><td>COCO+VOC07+12</td><td>78.8</td><td>-</td></tr><tr><td>COCO+VOC07++12</td><td>-</td><td>75.9</td></tr></table>",
            "id": 150,
            "page": 11,
            "text": "training data 2007 test 2012 test  VOC07 69.9 67.0  VOC07+12 73.2  VOC07++12 - 70.4  COCO (no VOC) 76.1 73.0  COCO+VOC07+12 78.8  COCO+VOC07++12 -"
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 1360
                },
                {
                    "x": 1939,
                    "y": 1360
                },
                {
                    "x": 1939,
                    "y": 1405
                },
                {
                    "x": 1190,
                    "y": 1405
                }
            ],
            "category": "paragraph",
            "html": "<p id='151' style='font-size:20px'>4.3 From MS COCO to PASCAL VOC</p>",
            "id": 151,
            "page": 11,
            "text": "4.3 From MS COCO to PASCAL VOC"
        },
        {
            "bounding_box": [
                {
                    "x": 1189,
                    "y": 1425
                },
                {
                    "x": 2195,
                    "y": 1425
                },
                {
                    "x": 2195,
                    "y": 1619
                },
                {
                    "x": 1189,
                    "y": 1619
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='152' style='font-size:20px'>Large-scale data is of crucial importance for improv-<br>ing deep neural networks. Next, we investigate how<br>the MS COCO dataset can help with the detection<br>performance on PASCAL VOC.</p>",
            "id": 152,
            "page": 11,
            "text": "Large-scale data is of crucial importance for improving deep neural networks. Next, we investigate how the MS COCO dataset can help with the detection performance on PASCAL VOC."
        },
        {
            "bounding_box": [
                {
                    "x": 1192,
                    "y": 1624
                },
                {
                    "x": 2198,
                    "y": 1624
                },
                {
                    "x": 2198,
                    "y": 2217
                },
                {
                    "x": 1192,
                    "y": 2217
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='153' style='font-size:16px'>As a simple baseline, we directly evaluate the<br>COCO detection model on the PASCAL VOC dataset,<br>without fine-tuning on any PASCAL VOC data. This<br>evaluation is possible because the categories on<br>COCO are a superset of those on PASCAL VOC. The<br>categories that are exclusive on COCO are ignored in<br>this experiment, and the softmax layer is performed<br>only on the 20 categories plus background. The mAP<br>under this setting is 76.1% on the PASCAL VOC 2007<br>test set (Table 12). This result is better than that trained<br>on VOC07+12 (73.2%) by a good margin, even though<br>the PASCAL VOC data are not exploited.</p>",
            "id": 153,
            "page": 11,
            "text": "As a simple baseline, we directly evaluate the COCO detection model on the PASCAL VOC dataset, without fine-tuning on any PASCAL VOC data. This evaluation is possible because the categories on COCO are a superset of those on PASCAL VOC. The categories that are exclusive on COCO are ignored in this experiment, and the softmax layer is performed only on the 20 categories plus background. The mAP under this setting is 76.1% on the PASCAL VOC 2007 test set (Table 12). This result is better than that trained on VOC07+12 (73.2%) by a good margin, even though the PASCAL VOC data are not exploited."
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 2220
                },
                {
                    "x": 2199,
                    "y": 2220
                },
                {
                    "x": 2199,
                    "y": 2915
                },
                {
                    "x": 1190,
                    "y": 2915
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='154' style='font-size:16px'>Then we fine-tune the COCO detection model on<br>the VOC dataset. In this experiment, the COCO model<br>is in place of the ImageNet-pre-trained model (that<br>is used to initialize the network weights), and the<br>Faster R-CNN system is fine-tuned as described in<br>Section 3.2. Doing so leads to 78.8% mAP on the<br>PASCAL VOC 2007 test set. The extra data from<br>the COCO set increases the mAP by 5.6%. Table 6<br>shows that the model trained on COCO+VOC has<br>the best AP for every individual category on PASCAL<br>VOC 2007. Similar improvements are observed on the<br>PASCAL VOC 2012 test set (Table 12 and Table 7). We<br>note that the test-time speed of obtaining these strong<br>results is still about 200ms per image.</p>",
            "id": 154,
            "page": 11,
            "text": "Then we fine-tune the COCO detection model on the VOC dataset. In this experiment, the COCO model is in place of the ImageNet-pre-trained model (that is used to initialize the network weights), and the Faster R-CNN system is fine-tuned as described in Section 3.2. Doing so leads to 78.8% mAP on the PASCAL VOC 2007 test set. The extra data from the COCO set increases the mAP by 5.6%. Table 6 shows that the model trained on COCO+VOC has the best AP for every individual category on PASCAL VOC 2007. Similar improvements are observed on the PASCAL VOC 2012 test set (Table 12 and Table 7). We note that the test-time speed of obtaining these strong results is still about 200ms per image."
        },
        {
            "bounding_box": [
                {
                    "x": 1190,
                    "y": 2956
                },
                {
                    "x": 1579,
                    "y": 2956
                },
                {
                    "x": 1579,
                    "y": 3008
                },
                {
                    "x": 1190,
                    "y": 3008
                }
            ],
            "category": "paragraph",
            "html": "<p id='155' style='font-size:22px'>5 CONCLUSION</p>",
            "id": 155,
            "page": 11,
            "text": "5 CONCLUSION"
        },
        {
            "bounding_box": [
                {
                    "x": 1191,
                    "y": 3026
                },
                {
                    "x": 2194,
                    "y": 3026
                },
                {
                    "x": 2194,
                    "y": 3126
                },
                {
                    "x": 1191,
                    "y": 3126
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='156' style='font-size:20px'>We have presented RPNs for efficient and accurate<br>region proposal generation. By sharing convolutional</p>",
            "id": 156,
            "page": 11,
            "text": "We have presented RPNs for efficient and accurate region proposal generation. By sharing convolutional"
        },
        {
            "bounding_box": [
                {
                    "x": 2159,
                    "y": 120
                },
                {
                    "x": 2197,
                    "y": 120
                },
                {
                    "x": 2197,
                    "y": 152
                },
                {
                    "x": 2159,
                    "y": 152
                }
            ],
            "category": "header",
            "html": "<header id='157' style='font-size:14px'>12</header>",
            "id": 157,
            "page": 12,
            "text": "12"
        },
        {
            "bounding_box": [
                {
                    "x": 475,
                    "y": 208
                },
                {
                    "x": 1842,
                    "y": 208
                },
                {
                    "x": 1842,
                    "y": 2415
                },
                {
                    "x": 475,
                    "y": 2415
                }
            ],
            "category": "figure",
            "html": "<figure><img id='158' style='font-size:14px' alt=\"cow :0.995\nbird:0.902\nperson:0.988\nperson:0.992\nperson:0.797 bird:0.978\ncar 0:746\nhorse:0.991\ncar:\nbird:0.972 0.998\nbird:0.941\n2006\nbottle r 0.726\nperson:096 person:0.988 person 10.986 :0.959\n976\nperson 0.929\nerson 0.991 car:0.997\ndog:0.981\ncow:0.979 erson:0.995\n[*]\n96 cow:0.974\nperson20.958\ncow:0.979\nbus:0.999\ncow:0.892\ncow:0\nperson:0.985 :0.995.son:0.996\nperson\n0.757\nperson:0.917\n:0.67\ncar:1,000 0.749\nboat:0.895\nboat:0.877\nperson:0.988\nperson: 0.995\nperson 0.994person:0.981\nperson:0.930 0.972\nicycle\n0.9\nboat:0.992\n0.962\ndog:0\npottedplant-g0.951\nbottle:0.851\nboat:0.69 0.791\ndiningtab\nboat:0.846\nperson: 0.948\nperson:0.972 : 0.919\nperson\n1.00\n0.981\n982\nboat:0.995\nboat 0.948\notable:\nbottle:0.826\ngleebooks\nboat: D 6\nperson: 0 .975\nerool bird:0.998\naeroplane:0\nleep:0.9\nbird:0.980\nbird:0.806 person: 0.670\nhorse:0.984\naeroplane:0.998\nAR AIRW AYS dull\nn\npottedplant:0.820\nC: Lothar Lenz\n··· www.pferdefotoarchiv\nchair: 0.98ihingtable-0.997\npottedplant:0.993 chair:0.978\nchair : 0.962\nhair 0.976\npottedplant:0.71 0.80 person:0.987\nerson: 0.993\npottedplant:0.940\npottedplant : 0.869\nerson:0.983\naeroplane:0.978 bird:0.997\nmonitor:0.993\nperson:0.959\nperson: 0.968 :0.982 ymanitor:0.993\nson:0.988\n0.852 0.616pottle person 0.897\nerson:0.870\nottle 0.8\nbird:0.727\" data-coord=\"top-left:(475,208); bottom-right:(1842,2415)\" /></figure>",
            "id": 158,
            "page": 12,
            "text": "cow :0.995 bird:0.902 person:0.988 person:0.992 person:0.797 bird:0.978 car 0:746 horse:0.991 car: bird:0.972 0.998 bird:0.941 2006 bottle r 0.726 person:096 person:0.988 person 10.986 :0.959 976 person 0.929 erson 0.991 car:0.997 dog:0.981 cow:0.979 erson:0.995 [*] 96 cow:0.974 person20.958 cow:0.979 bus:0.999 cow:0.892 cow:0 person:0.985 :0.995.son:0.996 person 0.757 person:0.917 :0.67 car:1,000 0.749 boat:0.895 boat:0.877 person:0.988 person: 0.995 person 0.994person:0.981 person:0.930 0.972 icycle 0.9 boat:0.992 0.962 dog:0 pottedplant-g0.951 bottle:0.851 boat:0.69 0.791 diningtab boat:0.846 person: 0.948 person:0.972 : 0.919 person 1.00 0.981 982 boat:0.995 boat 0.948 otable: bottle:0.826 gleebooks boat: D 6 person: 0 .975 erool bird:0.998 aeroplane:0 leep:0.9 bird:0.980 bird:0.806 person: 0.670 horse:0.984 aeroplane:0.998 AR AIRW AYS dull n pottedplant:0.820 C: Lothar Lenz ··· www.pferdefotoarchiv chair: 0.98ihingtable-0.997 pottedplant:0.993 chair:0.978 chair : 0.962 hair 0.976 pottedplant:0.71 0.80 person:0.987 erson: 0.993 pottedplant:0.940 pottedplant : 0.869 erson:0.983 aeroplane:0.978 bird:0.997 monitor:0.993 person:0.959 person: 0.968 :0.982 ymanitor:0.993 son:0.988 0.852 0.616pottle person 0.897 erson:0.870 ottle 0.8 bird:0.727"
        },
        {
            "bounding_box": [
                {
                    "x": 142,
                    "y": 2414
                },
                {
                    "x": 2201,
                    "y": 2414
                },
                {
                    "x": 2201,
                    "y": 2677
                },
                {
                    "x": 142,
                    "y": 2677
                }
            ],
            "category": "caption",
            "html": "<br><caption id='159' style='font-size:18px'>Figure 5: Selected examples of object detection results on the PASCAL VOC 2007 test set using the Faster<br>R-CNN system. The model is VGG-16 and the training data is 07+12 trainval (73.2% mAP on the 2007 test<br>set). Our method detects objects of a wide range of scales and aspect ratios. Each output box is associated<br>with a category label and a softmax score in [0, 1]. A score threshold of 0.6 is used to display these images.<br>The running time for obtaining these results is 198ms per image, including all steps.</caption>",
            "id": 159,
            "page": 12,
            "text": "Figure 5: Selected examples of object detection results on the PASCAL VOC 2007 test set using the Faster R-CNN system. The model is VGG-16 and the training data is 07+12 trainval (73.2% mAP on the 2007 test set). Our method detects objects of a wide range of scales and aspect ratios. Each output box is associated with a category label and a softmax score in . A score threshold of 0.6 is used to display these images. The running time for obtaining these results is 198ms per image, including all steps."
        },
        {
            "bounding_box": [
                {
                    "x": 142,
                    "y": 2767
                },
                {
                    "x": 1153,
                    "y": 2767
                },
                {
                    "x": 1153,
                    "y": 3070
                },
                {
                    "x": 142,
                    "y": 3070
                }
            ],
            "category": "paragraph",
            "html": "<p id='160' style='font-size:20px'>features with the down-stream detection network, the<br>region proposal step is nearly cost-free. Our method<br>enables a unified, deep-learning-based object detec-<br>tion system to run at near real-time frame rates. The<br>learned RPN also improves region proposal quality<br>and thus the overall object detection accuracy.</p>",
            "id": 160,
            "page": 12,
            "text": "features with the down-stream detection network, the region proposal step is nearly cost-free. Our method enables a unified, deep-learning-based object detection system to run at near real-time frame rates. The learned RPN also improves region proposal quality and thus the overall object detection accuracy."
        },
        {
            "bounding_box": [
                {
                    "x": 1191,
                    "y": 2763
                },
                {
                    "x": 1504,
                    "y": 2763
                },
                {
                    "x": 1504,
                    "y": 2815
                },
                {
                    "x": 1191,
                    "y": 2815
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='161' style='font-size:22px'>REFERENCES</p>",
            "id": 161,
            "page": 12,
            "text": "REFERENCES"
        },
        {
            "bounding_box": [
                {
                    "x": 1188,
                    "y": 2880
                },
                {
                    "x": 2201,
                    "y": 2880
                },
                {
                    "x": 2201,
                    "y": 3127
                },
                {
                    "x": 1188,
                    "y": 3127
                }
            ],
            "category": "paragraph",
            "html": "<p id='162' style='font-size:16px'>[1] K. He, X. Zhang, S. Ren, and J. Sun, \"Spatial pyramid pooling<br>in deep convolutional networks for visual recognition,\" in<br>European Conference on Computer Vision (ECCV), 2014.<br>[2] R. Girshick, \"Fast R-CNN,\" in IEEE International Conference on<br>Computer Vision (ICCV), 2015.<br>[3] K. Simonyan and A. Zisserman, \"Very deep convolutional</p>",
            "id": 162,
            "page": 12,
            "text": " K. He, X. Zhang, S. Ren, and J. Sun, \"Spatial pyramid pooling in deep convolutional networks for visual recognition,\" in European Conference on Computer Vision (ECCV), 2014.  R. Girshick, \"Fast R-CNN,\" in IEEE International Conference on Computer Vision (ICCV), 2015.  K. Simonyan and A. Zisserman, \"Very deep convolutional"
        },
        {
            "bounding_box": [
                {
                    "x": 2159,
                    "y": 120
                },
                {
                    "x": 2196,
                    "y": 120
                },
                {
                    "x": 2196,
                    "y": 151
                },
                {
                    "x": 2159,
                    "y": 151
                }
            ],
            "category": "header",
            "html": "<header id='163' style='font-size:16px'>13</header>",
            "id": 163,
            "page": 13,
            "text": "13"
        },
        {
            "bounding_box": [
                {
                    "x": 444,
                    "y": 208
                },
                {
                    "x": 1911,
                    "y": 208
                },
                {
                    "x": 1911,
                    "y": 2332
                },
                {
                    "x": 444,
                    "y": 2332
                }
            ],
            "category": "figure",
            "html": "<figure><img id='164' style='font-size:14px' alt=\"0.802\nperson\nairplane:0.997\nson:0.759\nperson:0.766 ackpac 0.772\nperson:(Rerson: person\n:0.867 0.897 :0.95\nersonsnow orella:0.824\n0.986\noao:0.848 person10.805 person:0.95\nson:0.93\n0916 person:0.970\nmotorcy\ndog:0.996\nbicycle10.891\ndog:0.691 bicycle:0.639\nperson:0.996\nperson :0.800\nmotorcycle:0.827 O 16\npizza.0.985\nperson:0.998\nble:0.956\n:0.938\nbed:0.999\nizza:0.995\npizza: 0.982\n:0.919 bottle:0.627\n759\nAITORR\nboat:0.992\n:0.934\nsurfboard:0.979 umbrella:0.885\n:0.716\nn:0.665\n0.692 person:0.618\nperson:0.813 person\nedde\nbus.0.99\nteddybear: 0.738 teddy bear:0.802\npottedplant:0.769\npart.off\nteddybear:0.890\neuROLines peperson:0.869\nbowl:0.602 sink :0976\nsink:0.994\ntoilet:0.921 sink:0992\nsink:0.969\nbook:0.611\ntv:0.964\nbottle:0.768 trafficlight:0.713\nlaptop:0.98 traffic light:0.869\ntrain:0.965\ncouch:0.991 at:0.613 boat:0.745\nmouse:0.871\ncouch:0.719 tv:0.959\nkeyboard:0.956\nc.table:0.637\niouse:0.677\n0.631 nch:0.971\nchair:0.644 erson:0\nfrisbee :0.998\ncup:0.931\ncup:0.986\ningtable:0.941\nbird:0.968\ndog:0.966\nbowl:0.958\nzebra:0.996\nzebra :0.Izebra:0.848\nzebra-0.993 andwich:0.62\nbird:0.987\nbird:0.894\ntv:0.2\nrefrigerator:0.699\nperson:0.993\nbottle:0.9\ntapto g\ntennis racket:0.960 norse:0.990\nbird:0.746\noven:0.655 bird:0.956\neyboard:0.6\nbird:0.906\nkeyboard:0.615\nmouse:0.981\n0.81 toothor ush:0.66\nrefrigerator:0631 pizza:0.919\nkite:0.934\nclock:0.988\nbowl:0.744\nbowl:0.816\nbowl:0.710\n0.8\ncup:0.807\npizza:0.965\nchair:0.772\noven:0.969\ndining table:0.618\" data-coord=\"top-left:(444,208); bottom-right:(1911,2332)\" /></figure>",
            "id": 164,
            "page": 13,
            "text": "0.802 person airplane:0.997 son:0.759 person:0.766 ackpac 0.772 person:(Rerson: person :0.867 0.897 :0.95 ersonsnow orella:0.824 0.986 oao:0.848 person10.805 person:0.95 son:0.93 0916 person:0.970 motorcy dog:0.996 bicycle10.891 dog:0.691 bicycle:0.639 person:0.996 person :0.800 motorcycle:0.827 O 16 pizza.0.985 person:0.998 ble:0.956 :0.938 bed:0.999 izza:0.995 pizza: 0.982 :0.919 bottle:0.627 759 AITORR boat:0.992 :0.934 surfboard:0.979 umbrella:0.885 :0.716 n:0.665 0.692 person:0.618 person:0.813 person edde bus.0.99 teddybear: 0.738 teddy bear:0.802 pottedplant:0.769 part.off teddybear:0.890 euROLines peperson:0.869 bowl:0.602 sink :0976 sink:0.994 toilet:0.921 sink:0992 sink:0.969 book:0.611 tv:0.964 bottle:0.768 trafficlight:0.713 laptop:0.98 traffic light:0.869 train:0.965 couch:0.991 at:0.613 boat:0.745 mouse:0.871 couch:0.719 tv:0.959 keyboard:0.956 c.table:0.637 iouse:0.677 0.631 nch:0.971 chair:0.644 erson:0 frisbee :0.998 cup:0.931 cup:0.986 ingtable:0.941 bird:0.968 dog:0.966 bowl:0.958 zebra:0.996 zebra :0.Izebra:0.848 zebra-0.993 andwich:0.62 bird:0.987 bird:0.894 tv:0.2 refrigerator:0.699 person:0.993 bottle:0.9 tapto g tennis racket:0.960 norse:0.990 bird:0.746 oven:0.655 bird:0.956 eyboard:0.6 bird:0.906 keyboard:0.615 mouse:0.981 0.81 toothor ush:0.66 refrigerator:0631 pizza:0.919 kite:0.934 clock:0.988 bowl:0.744 bowl:0.816 bowl:0.710 0.8 cup:0.807 pizza:0.965 chair:0.772 oven:0.969 dining table:0.618"
        },
        {
            "bounding_box": [
                {
                    "x": 140,
                    "y": 2339
                },
                {
                    "x": 2202,
                    "y": 2339
                },
                {
                    "x": 2202,
                    "y": 2550
                },
                {
                    "x": 140,
                    "y": 2550
                }
            ],
            "category": "caption",
            "html": "<br><caption id='165' style='font-size:20px'>Figure 6: Selected examples of object detection results on the MS COCO test-dev set using the Faster R-CNN<br>system. The model is VGG-16 and the training data is COCO trainval (42.7% mAP@0.5 on the test-dev set).<br>Each output box is associated with a category label and a softmax score in [0, 1]. A score threshold of 0.6 is<br>used to display these images. For each image, one color represents one object category in that image.</caption>",
            "id": 165,
            "page": 13,
            "text": "Figure 6: Selected examples of object detection results on the MS COCO test-dev set using the Faster R-CNN system. The model is VGG-16 and the training data is COCO trainval (42.7% mAP@0.5 on the test-dev set). Each output box is associated with a category label and a softmax score in . A score threshold of 0.6 is used to display these images. For each image, one color represents one object category in that image."
        },
        {
            "bounding_box": [
                {
                    "x": 134,
                    "y": 2650
                },
                {
                    "x": 1161,
                    "y": 2650
                },
                {
                    "x": 1161,
                    "y": 3116
                },
                {
                    "x": 134,
                    "y": 3116
                }
            ],
            "category": "paragraph",
            "html": "<p id='166' style='font-size:18px'>networks for large-scale image recognition,\" in International<br>Conference on Learning Representations (ICLR), 2015.<br>[4] J. R. Uijlings, K. E. van de Sande, T. Gevers, and A. W. Smeul-<br>ders, \"Selective search for object recognition, International<br>Journal of Computer Vision (IJCV), 2013.<br>[5] R. Girshick, J. Donahue, T. Darrell, and J. Malik, \"Rich feature<br>hierarchies for accurate object detection and semantic seg-<br>mentation, \" in IEEE Conference on Computer Vision and Pattern<br>Recognition (CVPR), 2014.<br>[6] C. L. Zitnick and P. Dollar, \"Edge boxes: Locating object<br>proposals from edges,\" in European Conference on Computer<br>Vision (ECCV), 2014.</p>",
            "id": 166,
            "page": 13,
            "text": "networks for large-scale image recognition,\" in International Conference on Learning Representations (ICLR), 2015.  J. R. Uijlings, K. E. van de Sande, T. Gevers, and A. W. Smeulders, \"Selective search for object recognition, International Journal of Computer Vision (IJCV), 2013.  R. Girshick, J. Donahue, T. Darrell, and J. Malik, \"Rich feature hierarchies for accurate object detection and semantic segmentation, \" in IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2014.  C. L. Zitnick and P. Dollar, \"Edge boxes: Locating object proposals from edges,\" in European Conference on Computer Vision (ECCV), 2014."
        },
        {
            "bounding_box": [
                {
                    "x": 1191,
                    "y": 2648
                },
                {
                    "x": 2203,
                    "y": 2648
                },
                {
                    "x": 2203,
                    "y": 3120
                },
                {
                    "x": 1191,
                    "y": 3120
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='167' style='font-size:18px'>[7] J. Long, E. Shelhamer, and T. Darrell, \"Fully convolutional<br>networks for semantic segmentation,\" in IEEE Conference on<br>Computer Vision and Pattern Recognition (CVPR), 2015.<br>[8] P. F. Felzenszwalb, R. B. Girshick, D. McAllester, and D. Ra-<br>manan, \"Object detection with discriminatively trained part-<br>based models, \" IEEE Transactions on Pattern Analysis and Ma-<br>chine Intelligence (TPAMI), 2010.<br>[9] P. Sermanet, D. Eigen, X. Zhang, M. Mathieu, R. Fergus,<br>and Y. LeCun, \"Overfeat: Integrated recognition, localization<br>and detection using convolutional networks,\" in International<br>Conference on Learning Representations (ICLR), 2014.<br>[10] S. Ren, K. He, R. Girshick, and J. Sun, \"Faster R-CNN: Towards</p>",
            "id": 167,
            "page": 13,
            "text": " J. Long, E. Shelhamer, and T. Darrell, \"Fully convolutional networks for semantic segmentation,\" in IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2015.  P. F. Felzenszwalb, R. B. Girshick, D. McAllester, and D. Ramanan, \"Object detection with discriminatively trained partbased models, \" IEEE Transactions on Pattern Analysis and Machine Intelligence (TPAMI), 2010.  P. Sermanet, D. Eigen, X. Zhang, M. Mathieu, R. Fergus, and Y. LeCun, \"Overfeat: Integrated recognition, localization and detection using convolutional networks,\" in International Conference on Learning Representations (ICLR), 2014.  S. Ren, K. He, R. Girshick, and J. Sun, \"Faster R-CNN: Towards"
        },
        {
            "bounding_box": [
                {
                    "x": 2161,
                    "y": 121
                },
                {
                    "x": 2195,
                    "y": 121
                },
                {
                    "x": 2195,
                    "y": 150
                },
                {
                    "x": 2161,
                    "y": 150
                }
            ],
            "category": "header",
            "html": "<header id='168' style='font-size:14px'>14</header>",
            "id": 168,
            "page": 14,
            "text": "14"
        },
        {
            "bounding_box": [
                {
                    "x": 220,
                    "y": 241
                },
                {
                    "x": 1151,
                    "y": 241
                },
                {
                    "x": 1151,
                    "y": 316
                },
                {
                    "x": 220,
                    "y": 316
                }
            ],
            "category": "paragraph",
            "html": "<p id='169' style='font-size:20px'>real-time object detection with region proposal networks,\" in<br>Neural Information Processing Systems (NIPS), 2015.</p>",
            "id": 169,
            "page": 14,
            "text": "real-time object detection with region proposal networks,\" in Neural Information Processing Systems (NIPS), 2015."
        },
        {
            "bounding_box": [
                {
                    "x": 145,
                    "y": 289
                },
                {
                    "x": 1154,
                    "y": 289
                },
                {
                    "x": 1154,
                    "y": 3121
                },
                {
                    "x": 145,
                    "y": 3121
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='170' style='font-size:16px'>[11] M. Everingham, L. Van Gool, C. K. I. Williams, J. Winn, and<br>A. Zisserman, \"The PASCAL Visual Object Classes Challenge<br>2007 (VOC2007) Results, \" 2007.<br>[12] T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Perona, D. Ra-<br>manan, P. Dollar, and C. L. Zitnick, \"Microsoft COCO: Com-<br>mon Objects in Context,\" in European Conference on Computer<br>Vision (ECCV), 2014.<br>[13] S. Song and J. Xiao, \"Deep sliding shapes for amodal 3d object<br>detection in rgb-d images,\" arXiv:1511.02300, 2015.<br>[14] J. Zhu, X. Chen, and A. L. Yuille, \"DeePM: A deep part-based<br>model for object detection and semantic part localization,\"<br>arXiv:1511.07131, 2015.<br>[15] J. Dai, K. He, and J. Sun, \"Instance-aware semantic segmenta-<br>tion via multi-task network cascades,\" arXiv:1512.04412, 2015.<br>[16] J. Johnson, A. Karpathy, and L. Fei-Fei, \"Densecap: Fully<br>convolutional localization networks for dense captioning,<br>arXiv:1511.07571, 2015.<br>[17] D. Kislyuk, Y. Liu, D. Liu, E. Tzeng, and Y. Jing, \"Human cu-<br>ration and convnets: Powering item-to-item recommendations<br>on pinterest,\" arXiv:1511.04003, 2015.<br>[18] K. He, X. Zhang, S. Ren, and J. Sun, \"Deep residual learning<br>for image recognition, \" arXiv:1512.03385, 2015.<br>[19] J. Hosang, R. Benenson, and B. Schiele, \"How good are de-<br>tection proposals, really?\" in British Machine Vision Conference<br>(BMVC), 2014.<br>[20] J. Hosang, R. Benenson, P. Dollar, and B. Schiele, \"What makes<br>for effective detection proposals?\" IEEE Transactions on Pattern<br>Analysis and Machine Intelligence (TPAMI), 2015.<br>[21] N. Chavali, H. Agrawal, A. Mahendru, and D. Batra,<br>\"Object-Proposal Evaluation Protocol is 'Gameable',\" arXiv:<br>1505.05836, 2015.<br>[22] J. Carreira and C. Sminchisescu, \"CPMC: Automatic ob-<br>ject segmentation using constrained parametric min-cuts,\"<br>IEEE Transactions on Pattern Analysis and Machine Intelligence<br>(TPAMI), 2012.<br>[23] P. Arbel�ez, J. Pont-Tuset, J. T. Barron, F. Marques, and J. Malik,<br>\"Multiscale combinatorial grouping, \" in IEEE Conference on<br>Computer Vision and Pattern Recognition (CVPR), 2014.<br>[24] B. Alexe, T. Deselaers, and V. Ferrari, \"Measuring the object-<br>ness of image windows, IEEE Transactions on Pattern Analysis<br>and Machine Intelligence (TPAMI), 2012.<br>[25] C. Szegedy, A. Toshev, and D. Erhan, \"Deep neural networks<br>for object detection,\" in Neural Information Processing Systems<br>(NIPS), 2013.<br>[26] D. Erhan, C. Szegedy, A. Toshev, and D. Anguelov, \"Scalable<br>object detection using deep neural networks,\" in IEEE Confer-<br>ence on Computer Vision and Pattern Recognition (CVPR), 2014.<br>[27] C. Szegedy, S. Reed, D. Erhan, and D. Anguelov, \"Scalable,<br>high-quality object detection,\" arXiv:1412.1441 (v1), 2015.<br>[28] P. O. Pinheiro, R. Collobert, and P. Dollar, \"Learning to<br>segment object candidates,\" in Neural Information Processing<br>Systems (NIPS), 2015.<br>[29] J. Dai, K. He, and J. Sun, \"Convolutional feature masking<br>for joint object and stuff segmentation, \" in IEEE Conference on<br>Computer Vision and Pattern Recognition (CVPR), 2015.<br>[30] S. Ren, K. He, R. Girshick, X. Zhang, and J. Sun, \"Ob-<br>ject detection networks on convolutional feature maps,\"<br>arXiv:1504.06066, 2015.<br>[31] J. K. Chorowski, D. Bahdanau, D. Serdyuk, K. Cho, and<br>Y. Bengio, \"Attention-based models for speech recognition,\"<br>in Neural Information Processing Systems (NIPS), 2015.<br>[32] M. D. Zeiler and R. Fergus, \"Visualizing and understanding<br>convolutional neural networks,\" in European Conference on<br>Computer Vision (ECCV), 2014.<br>[33] V. Nair and G. E. Hinton, \"Rectified linear units improve<br>restricted boltzmann machines, \" in International Conference on<br>Machine Learning (ICML), 2010.<br>[34] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov,<br>D. Erhan, and A. Rabinovich, \"Going deeper with convo-<br>lutions,\" in IEEE Conference on Computer Vision and Pattern<br>Recognition (CVPR), 2015.<br>[35] Y. LeCun, B. Boser, J. S. Denker, D. Henderson, R. E. Howard,<br>W. Hubbard, and L. D. Jackel, \"Backpropagation applied to<br>handwritten zip code recognition,\" Neural computation, 1989.</p>",
            "id": 170,
            "page": 14,
            "text": " M. Everingham, L. Van Gool, C. K. I. Williams, J. Winn, and A. Zisserman, \"The PASCAL Visual Object Classes Challenge 2007 (VOC2007) Results, \" 2007.  T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Perona, D. Ramanan, P. Dollar, and C. L. Zitnick, \"Microsoft COCO: Common Objects in Context,\" in European Conference on Computer Vision (ECCV), 2014.  S. Song and J. Xiao, \"Deep sliding shapes for amodal 3d object detection in rgb-d images,\" arXiv:1511.02300, 2015.  J. Zhu, X. Chen, and A. L. Yuille, \"DeePM: A deep part-based model for object detection and semantic part localization,\" arXiv:1511.07131, 2015.  J. Dai, K. He, and J. Sun, \"Instance-aware semantic segmentation via multi-task network cascades,\" arXiv:1512.04412, 2015.  J. Johnson, A. Karpathy, and L. Fei-Fei, \"Densecap: Fully convolutional localization networks for dense captioning, arXiv:1511.07571, 2015.  D. Kislyuk, Y. Liu, D. Liu, E. Tzeng, and Y. Jing, \"Human curation and convnets: Powering item-to-item recommendations on pinterest,\" arXiv:1511.04003, 2015.  K. He, X. Zhang, S. Ren, and J. Sun, \"Deep residual learning for image recognition, \" arXiv:1512.03385, 2015.  J. Hosang, R. Benenson, and B. Schiele, \"How good are detection proposals, really?\" in British Machine Vision Conference (BMVC), 2014.  J. Hosang, R. Benenson, P. Dollar, and B. Schiele, \"What makes for effective detection proposals?\" IEEE Transactions on Pattern Analysis and Machine Intelligence (TPAMI), 2015.  N. Chavali, H. Agrawal, A. Mahendru, and D. Batra, \"Object-Proposal Evaluation Protocol is 'Gameable',\" arXiv: 1505.05836, 2015.  J. Carreira and C. Sminchisescu, \"CPMC: Automatic object segmentation using constrained parametric min-cuts,\" IEEE Transactions on Pattern Analysis and Machine Intelligence (TPAMI), 2012.  P. Arbel�ez, J. Pont-Tuset, J. T. Barron, F. Marques, and J. Malik, \"Multiscale combinatorial grouping, \" in IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2014.  B. Alexe, T. Deselaers, and V. Ferrari, \"Measuring the objectness of image windows, IEEE Transactions on Pattern Analysis and Machine Intelligence (TPAMI), 2012.  C. Szegedy, A. Toshev, and D. Erhan, \"Deep neural networks for object detection,\" in Neural Information Processing Systems (NIPS), 2013.  D. Erhan, C. Szegedy, A. Toshev, and D. Anguelov, \"Scalable object detection using deep neural networks,\" in IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2014.  C. Szegedy, S. Reed, D. Erhan, and D. Anguelov, \"Scalable, high-quality object detection,\" arXiv:1412.1441 (v1), 2015.  P. O. Pinheiro, R. Collobert, and P. Dollar, \"Learning to segment object candidates,\" in Neural Information Processing Systems (NIPS), 2015.  J. Dai, K. He, and J. Sun, \"Convolutional feature masking for joint object and stuff segmentation, \" in IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2015.  S. Ren, K. He, R. Girshick, X. Zhang, and J. Sun, \"Object detection networks on convolutional feature maps,\" arXiv:1504.06066, 2015.  J. K. Chorowski, D. Bahdanau, D. Serdyuk, K. Cho, and Y. Bengio, \"Attention-based models for speech recognition,\" in Neural Information Processing Systems (NIPS), 2015.  M. D. Zeiler and R. Fergus, \"Visualizing and understanding convolutional neural networks,\" in European Conference on Computer Vision (ECCV), 2014.  V. Nair and G. E. Hinton, \"Rectified linear units improve restricted boltzmann machines, \" in International Conference on Machine Learning (ICML), 2010.  C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan, and A. Rabinovich, \"Going deeper with convolutions,\" in IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2015.  Y. LeCun, B. Boser, J. S. Denker, D. Henderson, R. E. Howard, W. Hubbard, and L. D. Jackel, \"Backpropagation applied to handwritten zip code recognition,\" Neural computation, 1989."
        },
        {
            "bounding_box": [
                {
                    "x": 1194,
                    "y": 239
                },
                {
                    "x": 2206,
                    "y": 239
                },
                {
                    "x": 2206,
                    "y": 734
                },
                {
                    "x": 1194,
                    "y": 734
                }
            ],
            "category": "paragraph",
            "html": "<br><p id='171' style='font-size:20px'>[36] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma,<br>Z. Huang, A. Karpathy, A. Khosla, M. Bernstein, A. C. Berg,<br>and L. Fei-Fei, \"ImageNet Large Scale Visual Recognition<br>Challenge,\" in International Journal of Computer Vision (IJCV),<br>2015.<br>[37] A. Krizhevsky, I. Sutskever, and G. Hinton, \"Imagenet classi-<br>fication with deep convolutional neural networks,\" in Neural<br>Information Processing Systems (NIPS), 2012.<br>[38] Y. Jia, E. Shelhamer, J. Donahue, S. Karayev, J. Long, R. Gir-<br>shick, S. Guadarrama, and T. Darrell, \"Caffe: Convolutional<br>architecture for fast feature embedding,\" arXiv:1408.5093, 2014.<br>[39] K. Lenc and A. Vedaldi, \"R-CNN minus R,\" in British Machine<br>Vision Conference (BMVC), 2015.</p>",
            "id": 171,
            "page": 14,
            "text": " O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein, A. C. Berg, and L. Fei-Fei, \"ImageNet Large Scale Visual Recognition Challenge,\" in International Journal of Computer Vision (IJCV), 2015.  A. Krizhevsky, I. Sutskever, and G. Hinton, \"Imagenet classification with deep convolutional neural networks,\" in Neural Information Processing Systems (NIPS), 2012.  Y. Jia, E. Shelhamer, J. Donahue, S. Karayev, J. Long, R. Girshick, S. Guadarrama, and T. Darrell, \"Caffe: Convolutional architecture for fast feature embedding,\" arXiv:1408.5093, 2014.  K. Lenc and A. Vedaldi, \"R-CNN minus R,\" in British Machine Vision Conference (BMVC), 2015."
        }
    ]
}